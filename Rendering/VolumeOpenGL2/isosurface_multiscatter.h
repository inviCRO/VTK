#ifndef ISOSURFACE_MULTISCATTER_H
#define ISOSURFACE_MULTISCATTER_H

const char* isosurface_multiscatter = "//VTK::System::Dec\n"
"\n"
"varying vec3 ip_textureCoords;\n"
"varying vec3 ip_vertexPos;\n"
"\n"
"vec4 g_fragColor = vec4(0.0);\n"
"\n"
"vec3 g_dataPos;\n"
"vec3 g_dirStep;\n"
"float g_rayStepLength;\n"
"vec4 g_srcColor;\n"
"vec4 g_eyePosObj;\n"
"bool g_exit;\n"
"uniform vec4 in_volume_scale;\n"
"uniform vec4 in_volume_bias;\n"
"\n"
"//VTK::Output::Dec\n"
"// Volume dataset\n"
"uniform sampler3D in_volume;\n"
"uniform int in_noOfComponents;\n"
"\n"
"uniform int in_independentComponents;\n"
"\n"
"uniform sampler2D in_noiseSampler;\n"
"uniform sampler2D in_depthSampler;\n"
"\n"
"// Camera position\n"
"uniform vec3 in_cameraPos;\n"
"\n"
"// view and model matrices\n"
"uniform mat4 in_projectionMatrix;\n"
"uniform mat4 in_inverseProjectionMatrix;\n"
"uniform mat4 in_modelViewMatrix;\n"
"uniform mat4 in_inverseModelViewMatrix;\n"
"uniform mat4 in_textureDatasetMatrix;\n"
"uniform mat4 in_inverseTextureDatasetMatrix;\n"
"uniform mat4 in_textureOriginMatrix;\n"
"uniform mat4 in_inverseVolumeMatrix;\n"
"uniform mat4 in_volumeMatrix;\n"
"mat4 invTextureOriginMatrix = inverse(in_textureOriginMatrix);\n"
"\n"
"// Ray step size\n"
"uniform vec3 in_cellStep;\n"
"uniform vec2 in_scalarsRange[4];\n"
"uniform vec3 in_cellSpacing;\n"
"uniform float in_croppingPlanes[6];\n"
"\n"
"// Sample distance\n"
"uniform float in_sampleDistance;\n"
"\n"
"// Scales\n"
"uniform vec3 in_cellScale;\n"
"uniform vec2 in_windowLowerLeftCorner;\n"
"uniform vec2 in_inverseOriginalWindowSize;\n"
"uniform vec2 in_inverseWindowSize;\n"
"uniform vec3 in_textureExtentsMax;\n"
"uniform vec3 in_textureExtentsMin;\n"
"\n"
"//ray and light angleuniform int in_twoSidedLighting;\n"
"vec3 g_xvec;\n"
"vec3 g_yvec;\n"
"vec3 g_zvec;\n"
"\n"
"// Material and lighting\n"
"uniform vec3 in_diffuse[4];\n"
"uniform vec3 in_ambient[4];\n"
"uniform vec3 in_specular[4];\n"
"uniform float in_shininess[4];\n"
"uniform vec3 in_lightAmbientColor[1];\n"
"uniform vec3 in_lightDiffuseColor[1];\n"
"uniform vec3 in_lightSpecularColor[1];\n"
"vec4 g_lightPosObj;\n"
"vec3 g_ldir;\n"
"vec3 g_vdir;\n"
"vec3 g_h;\n"
"vec3 g_aspect;\n"
"\n"
"vec3 computeRayDirection() {\n"
"    return normalize(ip_vertexPos.xyz - g_eyePosObj.xyz);\n"
"}\n"
"\n"
"//VTK::Picking::Dec\n"
"\n"
"uniform float in_clippingPlanes[49];\n"
"uniform float in_scale;\n"
"uniform float in_bias;\n"
"\n"
"\n"
"/*===================================VQ===============================*/\n"
"// cropping box coordinate in texture domain\n"
"bool l_skip = false;\n"
"vec4 l_bb_min = vec4(in_croppingPlanes[0], in_croppingPlanes[2], in_croppingPlanes[4], 1.0);"
"\n"
"// Maximum texture access coordinate\n"
"vec4 l_bb_max = vec4(in_croppingPlanes[1], in_croppingPlanes[3], in_croppingPlanes[5], 1.0);\n"

"/*===================================VQ===============================*/\n"
"//VQ:variables to support vtkvolume usermatrix\n"
"uniform mat4 in_originMatrix;\n"
"uniform mat4 in_InverseOriginMatrix;\n"
"uniform mat4 in_volumeUserMatrix;\n"
"uniform mat4 in_volumeInvUserMatrix;\n"
"uniform mat4 in_flipMatrix;\n"
"\n"
"uniform sampler2D in_opacityTransferFunc;\n"
"float computeOpacity(vec4 scalar) {\n"
"    return texture2D(in_opacityTransferFunc, vec2(scalar.w, 0)).r;\n"
"}\n"
"\n"
"uniform sampler3D in_gradient;\n"
"\n"
"uniform sampler2D in_gradientTransferFunc;\n"
"float computeGradientOpacity(vec4 grad) {\n"
"    return texture2D(in_gradientTransferFunc, vec2(grad.w,0)).r;\n"
"}\n"
"\n"
"uniform sampler2D in_colorTransferFunc;\n"
"vec4 computeColor(vec3 pos, float opacity) {\n"
"    vec4 scalar = texture3D(in_volume, pos);\n"
"    scalar = scalar * in_volume_scale + in_volume_bias;\n"
"    scalar = vec4(scalar.r, scalar.r, scalar.r, scalar.r);\n"
"    return vec4(texture2D(in_colorTransferFunc, vec2(scalar.w,0)).xyz, opacity);\n"
"}\n"
"\n"
"/*===================================VQ===============================*/\n"
"//VQ:tissue textures, will need to do string replace dynamically\n"
"//uniform sampler1D in_custom1DTransferFunc0;\n"
"//uniform sampler2D in_custom2DTransferFunc0;\n"
"\n"
"/*===================================VQ===============================*/\n"
"//VQ:define scatter event, this is the location where light get absored by tissue\n"
"struct scatterEvent {\n"
"    vec3 minT;\n"
"    vec3 pos;\n"
"    vec3 norm;\n"
"    float normWeight;\n"
"    float lightWeight;\n"
"    vec3 refRay;\n"
"    int event; //0 for volume, 1 for light, 2 for other object\n"
"    int valid;\n"
"};\n"
"\n"
"float random (vec2 st) {\n"
"    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n"
"}\n"
"\n"
"/*===================================VQ===============================*/\n"
"//VQ:get smoothed volume intensity with mean filter\n"
"vec4 ComputeSmoothVolumeIntensity(vec3 dataPos, int smoothness) {\n"
"    vec4 intensity = vec4(1.0);\n"
"    if (smoothness == 0) {\n"
"        intensity = texture3D(in_volume, dataPos);\n"
"    } else {\n"
"        vec4 sum = vec4(0.0);\n"
"        float cnt = 0.0;\n"
"        for (int i = -smoothness; i <= smoothness; i++) {\n"
"            for (int j = -smoothness; j <= smoothness; j++) {\n"
"                for (int k = -smoothness; k <= smoothness; k++) {\n"
"                    vec3 newPos = vec3(dataPos.x + float(i) * in_cellStep[0], dataPos.y + float(j) * in_cellStep[1], dataPos.z + float(k) * in_cellStep[2]);\n"
"                    intensity = texture3D(in_volume, newPos);\n"
"                    sum += intensity;\n"
"                    cnt += 1.0;\n"
"                }\n"
"            }\n"
"        }\n"
"        intensity = sum / cnt;\n"
"    }\n"
"    intensity = intensity * in_volume_scale + in_volume_bias;\n"
"    return intensity;\n"
"}\n"
"\n"
"/*===================================VQ===============================*/\n"
"//VQ:compute surface gradient\n"
"vec3 ComputeGradientNormal(vec3 dataPos, int smoothness) {\n"
"    vec4 gradientNormal = vec4(0.0);\n"
"    if (dataPos.x <= 0.0 ||\n"
"        dataPos.x >= 1.0 ||\n"
"        dataPos.y <= 0.0 ||\n"
"        dataPos.y >= 1.0 ||\n"
"        dataPos.z <= 0.0 ||\n"
"        dataPos.z >= 1.0) {\n"
"        return gradientNormal.rgb;\n"
"    }\n"
"\n"
"    vec3 direction = vec3(-1.0, 1.0, 1.0);\n"
"    float stepscale = 2.0;\n"
"    for (int i = 0; i < 3; i++) {\n"
"        vec3 g1dataPos = dataPos;\n"
"        g1dataPos[i] = g1dataPos[i] - stepscale * direction[i] * in_cellStep[i];\n"
"        vec3 g2dataPos = dataPos;\n"
"        g2dataPos[i] = g2dataPos[i] + stepscale * direction[i] * in_cellStep[i];\n"
"        vec4 g1 = ComputeSmoothVolumeIntensity(g1dataPos, smoothness);\n"
"        vec4 g2 = ComputeSmoothVolumeIntensity(g2dataPos, smoothness);\n"
"        g1 = g1 * in_volume_scale + in_volume_bias;\n"
"        g2 = g2 * in_volume_scale + in_volume_bias;\n"
"        gradientNormal[i] = length(g2.rgb) - length(g1.rgb);\n"
"    }\n"
"    return gradientNormal.rgb;\n"
"}\n"
"\n"
"/*===================================VQ===============================*/\n"
"//VQ:compute ray intercept with light, now unused\n"
"scatterEvent intersectLights(vec3 ray) {\n"
"    scatterEvent lightEvent;\n"
"    lightEvent.event = 1;\n"
"    lightEvent.valid = 0;\n"
"\n"
"    return lightEvent;\n"
"}\n"
"\n"
"/*===================================VQ===============================*/\n"
"//VQ:compute ray intercept with object like roi, now unused\n"
"scatterEvent intersectObject(vec3 pos, vec3 rayDir, int totalSamplePoint) {\n"
"    scatterEvent objectEvent;\n"
"    objectEvent.event = 2;\n"
"    if (totalSamplePoint > 0) {\n"
"        objectEvent.valid = 1;\n"
"        objectEvent.pos = pos + rayDir * float(totalSamplePoint);\n"
"    } else {\n"
"        objectEvent.valid = 0;\n"
"    }\n"
"    objectEvent.valid = 0;\n"
"    return objectEvent;\n"
"}\n"
"\n"
"/*===================================VQ===============================*/\n"
"//VQ:struct that store shader color\n"
"struct shaderInfo {\n"
"    vec3 reflectRay;\n"
"    vec4 emissionColor;\n"
"    vec4 diffuseColor;\n"
"    vec4 specularColor;\n"
"    float ior;\n"
"    float glossiness;\n"
"};\n"
"\n"
"/*===================================VQ===============================*/\n"
"//VQ:light information\n"
"struct lightInfo {\n"
"    vec3 surfaceN;\n"
"    vec3 surfaceP;\n"
"    vec3 pos;\n"
"    int type; //0 for point and 1 for plane\n"
"};\n"
"\n"
"const float INV_PI_F = 0.31830988618379067154;\n"
"const float INV_TWO_PI_F = 0.15915494309189533577;\n"
"const float PI_F = 3.141592654;\n"
"\n"
"struct normInfo {\n"
"    vec3 ldir;\n"
"    vec3 vdir;\n"
"    vec3 h;\n"
"};\n"
"\n"
"/*===================================VQ===============================*/\n"
"//VQ:light information.lightPos is in volume space and eyepos is in world space\n"
"normInfo computeLightCameraNormal(vec3 lightpos) {\n"
"\n"
"    // Light position in dataset space\n"
"    vec4 t_lightPosObj = (in_inverseVolumeMatrix * vec4(lightpos, 1.0));\n"
"    if (t_lightPosObj.w != 0.0) {\n"
"        t_lightPosObj.x /= t_lightPosObj.w;\n"
"        t_lightPosObj.y /= t_lightPosObj.w;\n"
"        t_lightPosObj.z /= t_lightPosObj.w;\n"
"        t_lightPosObj.w = 1.0;\n"
"    }\n"
"\n"
"    normInfo g_info;\n"
"    g_info.ldir = normalize(t_lightPosObj.xyz - ip_vertexPos);\n"
"    g_info.vdir = normalize(g_eyePosObj.xyz - ip_vertexPos);\n"
"    g_info.h = normalize(g_info.ldir + g_info.vdir);\n"
"    return g_info;\n"
"}\n"
"\n"
"void computeLightNormal() {\n"
"    // Light position in dataset space\n"
"    g_lightPosObj = (in_inverseVolumeMatrix * vec4(in_cameraPos, 1.0));\n"
"    if (g_lightPosObj.w != 0.0) {\n"
"        g_lightPosObj.x /= g_lightPosObj.w;\n"
"        g_lightPosObj.y /= g_lightPosObj.w;\n"
"        g_lightPosObj.z /= g_lightPosObj.w;\n"
"        g_lightPosObj.w = 1.0;\n"
"    }\n"
"    g_ldir = normalize(g_lightPosObj.xyz - ip_vertexPos);\n"
"    g_vdir = normalize(g_eyePosObj.xyz - ip_vertexPos);\n"
"    g_h = normalize(g_ldir + g_vdir);\n"
"    return;\n"
"}\n"
"\n"
"/*===================================VQ===============================*/\n"
"//VQ:get shader information, it map volume intensity to final color with transfer funciton or texture\n"
"shaderInfo getShader(scatterEvent event) {\n"
"    shaderInfo shader;\n"
"    shader.reflectRay = event.refRay;\n"
"    shader.emissionColor = computeColor(event.pos, 1.0);\n"
"    float mapping = length(cross(event.norm + 0.5, event.pos - 0.5));\n"
"    float radius = 6.0;\n"
"    //vec2 coorMapping = vec2(sqrt(radius * 2.0 / (radius + event.pos.z)) * event.pos.x, sqrt(radius * 2.0 / (radius + event.pos.z)) * event.pos.y);\n"
"    //vec4 diffusecol = texture2D(in_custom2DTransferFunc0, coorMapping);\n"
"    shader.diffuseColor = shader.emissionColor;\n"
"    shader.specularColor = vec4(0.9, 0.9, 0.9, shader.emissionColor.a);\n"
"    shader.ior = 0.5;\n"
"    shader.glossiness = in_shininess[0];\n"
"    return shader;\n"
"}\n"
"\n"
"/*===================================VQ===============================*/\n"
"//VQ:get light info, now only one spot light from camera\n"
"lightInfo getLightInfo() {\n"
"    lightInfo planeLight;\n"
"    planeLight.type = 1;\n"
"    planeLight.surfaceP = g_eyePosObj.xyz;\n"
"    planeLight.surfaceN = g_vdir;\n"
"    return planeLight;\n"
"}\n"
"\n"
"/*===================================VQ===============================*/\n"
"//VQ: shader, compute three lights\n"
"vec4 uniformSampleOneLight(scatterEvent event) {\n"
"    //init shader\n"
"    shaderInfo shader = getShader(event);\n"
"\n"
"    //init light\n"
"    lightInfo planeLight = getLightInfo();\n"
"    vec3 scatterPointtoLight = normalize(planeLight.surfaceP - event.pos);\n"
"\n"
"    //BRDF information\n"
"    vec3 normN = normalize(event.norm);\n"
"    vec3 normU = normalize(cross(event.norm, event.refRay));\n"
"    vec3 normV = normalize(cross(event.norm, normU));\n"
"    vec3 localRefRay = vec3(dot(event.refRay, normU), dot(event.refRay, normV), dot(event.refRay, normN));\n"
"    vec3 localScatterPointtoLight = vec3(dot(scatterPointtoLight, normU), dot(scatterPointtoLight, normV), dot(scatterPointtoLight, normN));\n"
"\n"
"    //diffuse effect\n"
"    float reflactfactor = abs(localScatterPointtoLight.z);\n"
"    vec4 diffuseColor = shader.diffuseColor * (reflactfactor);\n"
"    float cosThetaO = abs(localRefRay.z);\n"
"    float cosThetaI = abs(localScatterPointtoLight.z);\n"
"    vec4 reflectColor = diffuseColor;\n"
"\n"
"    //specular effect, the method is from exposure render\n"
"    float lambertianpdf = pow(cosThetaI, 2.0) * INV_PI_F;\n"
"    float bsfpdf = lambertianpdf;\n"
"    if (cosThetaO * cosThetaI > 0.0) {\n"
"        vec3 wh = normalize(localRefRay + localScatterPointtoLight);\n"
"        float cosTheta = abs(dot(localRefRay, localScatterPointtoLight));\n"
"        float microfacepdf = (shader.glossiness) * pow(cosTheta, shader.glossiness) / (2.0 * PI_F * 4.0 * cosTheta);\n"
"        bsfpdf += microfacepdf;\n"
"    }\n"
"    vec4 specularColor = vec4(0.0);\n"
"    if (bsfpdf > 0.0) {\n"
"        float lightpdf = normalize(distance(planeLight.surfaceP, event.pos)) / abs(dot(planeLight.surfaceN, scatterPointtoLight) * 4.0);\n"
"        float weightpdf = lightpdf * lightpdf / (lightpdf * lightpdf + bsfpdf * bsfpdf);\n"
"        weightpdf = 1.0 - weightpdf;\n"
"        specularColor = bsfpdf * abs(dot(scatterPointtoLight, planeLight.surfaceN)) * weightpdf * shader.specularColor;\n"
"    }\n"
"    vec4 finalColor = in_ambient[0][0] * shader.emissionColor + in_diffuse[0][0] * diffuseColor + in_specular[0][0] * specularColor;\n"
"\n"
"    //tone mapping\n"
"    bool toneMapping = false;\n"
"    if (toneMapping) {\n"
"        float exposure = 0.25;\n"
"        float invexposure = 1.0 / exposure;\n"
"        finalColor = 1.0 - exp(-finalColor * invexposure);\n"
"    }\n"
"    finalColor = clamp(finalColor, vec4(0.0), vec4(1.0));\n"
"    return finalColor;\n"
"}\n"
"\n"
"/*===================================VQ===============================*/\n"
"//VQ:compute the location where light get absored by tissue, now it only store one scatter point\n"
"vec4 sampleVolume(vec3 pos, vec3 rayDir, vec3 dirStep, float totalObjectSamplePoint) {\n"
"\n"
"\n"
"    float energy = 20.0;\n"
"    float remainEnergy = 0.0;\n"
"    float sigmaT = 0.0;\n"
"    float densityScale = 20.0;\n"
"    bool stop = false;\n"
"    float normalizedIntensity = 1.0;\n"
"\n"
"    const vec3 tex_min = vec3(0.0);\n"
"    const vec3 tex_max = vec3(1.0);\n"
"    vec4 color = vec4(0.0);\n"
"\n"
"    float l_currentT = 0.0;\n"
"    while (remainEnergy < energy && !stop && l_currentT <= totalObjectSamplePoint) {\n"
"        l_skip = dot(sign(pos - l_bb_min.xyz), sign(l_bb_max.xyz - pos)) < 3.0;\n"
"        vec4 intensity = texture3D(in_volume, pos);\n"
"        intensity = intensity * in_volume_scale + in_volume_bias;\n"
"        intensity.rgba = intensity.rrrr;\n"
"        float opacity = computeOpacity(intensity);\n"
"        normalizedIntensity = intensity.r;\n"
"        sigmaT = opacity * densityScale;\n"
"        if(sigmaT > 0.01 && !l_skip) {\n"
"            remainEnergy += sigmaT;\n"
"            scatterEvent volumeEvent;\n"
"            volumeEvent.event = 0;\n"
"            volumeEvent.valid = 1;\n"
"            vec3 norm = ComputeGradientNormal(pos, 0);\n"
"            norm = norm.xyz / in_cellSpacing;\n"
"            volumeEvent.pos = pos;\n"
"            volumeEvent.norm = normalize(norm);\n"
"            volumeEvent.normWeight = normalizedIntensity;\n"
"            volumeEvent.refRay = normalize(rayDir - 2.0 * (dot(rayDir, volumeEvent.norm)) * volumeEvent.norm);\n"
"            float weight = sigmaT / energy;\n"
"            vec4 scatterColor = uniformSampleOneLight(volumeEvent);\n"
"            color += weight * scatterColor;\n"
"            l_currentT += 1.0;\n"
"        }\n"
"        float zoomStepRate = clamp(densityScale * 10.0 * opacity, 1.0, 20.0);\n"
"        pos += dirStep / zoomStepRate;\n"
"        stop = dot(sign(pos - tex_min), sign(tex_max - pos)) < 3.0;\n"
"    }\n"
"    return color;\n"
"}\n"
"\n"
"/*===================================VQ===============================*/\n"
"//VQ:test ray intercept with either volume, light, or object, now only volume\n"
"vec4 sampleRay(vec3 pos, vec3 rayDir, vec3 dirStep, float totalObjectSamplePoint) {\n"
"\n"
"    //scatterEvent event[3];\n"
"    vec4 color = sampleVolume(pos, rayDir, dirStep, totalObjectSamplePoint);\n"
"    //event[1] = intersectLights(pos);\n"
"    //event[2] = intersectObject(pos, rayDir, totalObjectSamplePoint);\n"
"    return color;\n"
"}\n"
"\n"
"/*===================================VQ===============================*/\n"
"//VQ: select scatter position\n"
"vec4 multipleScattering(vec3 pos, vec3 rayDir, vec3 dirStep, float totalObjectSamplePoint) {\n"
"    vec4 color = sampleRay(pos, rayDir, dirStep, totalObjectSamplePoint);\n"
"    color.a = 1.0;\n"
"    return color;\n"
"}\n"
"/*******************************isosurface, vtk**********************************/\n"
"\n"
"void main() {\n"
"    /// Initialize g_fragColor (output) to 0\n"
"    g_fragColor = vec4(0.0);\n"
"    g_dirStep = vec3(0.0);\n"
"    g_srcColor = vec4(0.1);\n"
"    g_exit = false;\n"
"\n"
"/*compute bounding box minmax coordinate in texture domain*/\n"
"    l_bb_min = in_inverseTextureDatasetMatrix * l_bb_min;\n"
"    if (l_bb_min.w != 0.0)\n"
"    {\n"
"       l_bb_min.x /= l_bb_min.w;\n"
"       l_bb_min.y /= l_bb_min.w;\n"
"       l_bb_min.z /= l_bb_min.w;\n"
"       l_bb_min.w = 1.0;\n"
"    }\n"
"    l_bb_max = in_inverseTextureDatasetMatrix * l_bb_max;\n"
"    if (l_bb_max.w != 0.0)\n"
"    {\n"
"       l_bb_max.x /= l_bb_max.w;\n"
"       l_bb_max.y /= l_bb_max.w;\n"
"       l_bb_max.z /= l_bb_max.w;\n"
"       l_bb_max.w = 1.0;\n"
"    }\n"
"    // Get the 3D texture coordinates for lookup into the in_volume dataset\n"
"    vec4 texremapped = vec4(ip_textureCoords, 1.0);\n"
"    texremapped = invTextureOriginMatrix * in_flipMatrix * in_textureOriginMatrix * texremapped;\n"
"    g_dataPos = texremapped.xyz;\n"
"\n"
"    // Eye position in object space\n"
"    g_eyePosObj = (in_InverseOriginMatrix * in_volumeInvUserMatrix * in_originMatrix * vec4(in_cameraPos, 1.0));\n"
"    if (g_eyePosObj.w != 0.0) {\n"
"        g_eyePosObj.x /= g_eyePosObj.w;\n"
"        g_eyePosObj.y /= g_eyePosObj.w;\n"
"        g_eyePosObj.z /= g_eyePosObj.w;\n"
"        g_eyePosObj.w = 1.0;\n"
"    }\n"
"\n"
"    // Getting the ray marching direction (in object space);\n"
"    vec3 rayDir = computeRayDirection();\n"
"\n"
"    g_dirStep = (in_inverseTextureDatasetMatrix * invTextureOriginMatrix * in_flipMatrix * in_textureOriginMatrix * vec4(rayDir, 0.0)).xyz * in_sampleDistance;\n"
"    g_rayStepLength = length(g_dirStep);\n"
"\n"
"    g_dataPos += g_dirStep * (texture2D(in_noiseSampler, g_dataPos.xy).x);\n"
"\n"
"    bool stop = false;\n"
"\n"
"    vec2 fragTexCoord = (gl_FragCoord.xy - in_windowLowerLeftCorner) * in_inverseWindowSize;\n"
"    vec4 l_depthValue = texture2D(in_depthSampler, fragTexCoord);\n"
"    float l_terminatePointMax = 0.0;\n"
"\n"
"    // Depth test\n"
"    if (gl_FragCoord.z >= l_depthValue.x) {\n"
"        discard;\n"
"    }\n"
"\n"
"    vec4 terminatePoint;\n"
"    terminatePoint.x = (gl_FragCoord.x - in_windowLowerLeftCorner.x) * 2.0 * in_inverseWindowSize.x - 1.0;\n"
"    terminatePoint.y = (gl_FragCoord.y - in_windowLowerLeftCorner.y) * 2.0 * in_inverseWindowSize.y - 1.0;\n"
"    terminatePoint.z = (2.0 * l_depthValue.x - (gl_DepthRange.near + gl_DepthRange.far)) / gl_DepthRange.diff;\n"
"    terminatePoint.w = 1.0;\n"
"\n"
"    terminatePoint = in_inverseTextureDatasetMatrix *\n"
"        in_originMatrix * in_volumeInvUserMatrix * in_InverseOriginMatrix * in_inverseModelViewMatrix * in_inverseProjectionMatrix * terminatePoint;\n"
"    terminatePoint /= terminatePoint.w;\n"
"    l_terminatePointMax = length(terminatePoint.xyz - ip_textureCoords.xyz) / g_rayStepLength;\n"
"\n"
"    computeLightNormal();\n"
"\n"
"    // For all samples along the ray\n"
"    g_srcColor = multipleScattering(g_dataPos, rayDir, g_dirStep, l_terminatePointMax);\n"
"\n"
"    g_fragColor.rgb = g_srcColor.rgb * g_srcColor.a;\n"
"    g_fragColor.a = g_srcColor.a;\n"
"\n"
"    g_fragColor.r = g_fragColor.r * in_scale + in_bias * g_fragColor.a;\n"
"    g_fragColor.g = g_fragColor.g * in_scale + in_bias * g_fragColor.a;\n"
"    g_fragColor.b = g_fragColor.b * in_scale + in_bias * g_fragColor.a;\n"
"\n"
"    gl_FragData[0] = g_fragColor;\n"
"}\n";
#endif
