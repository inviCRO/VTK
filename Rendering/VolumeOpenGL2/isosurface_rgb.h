#ifndef ISOSURFACE_RGB_H
#define ISOSURFACE_RGB_H
const char* isosurface_rgb ="//VTK::System::Dec\n"
"\n"
"varying vec3 ip_textureCoords;\n"
"varying vec3 ip_vertexPos;\n"
"\n"
"vec4 g_fragColor = vec4(0.0);\n"
"\n"
"vec3 g_dataPos;\n"
"vec3 g_dirStep;\n"
"vec4 g_srcColor;\n"
"vec4 g_eyePosObj;\n"
"bool g_exit;\n"
"\n"
"uniform vec4 in_volume_scale;\n"
"uniform vec4 in_volume_bias;\n"
"\n"
"//VTK::Output::Dec\n"
"// Volume dataset\n"
"uniform sampler3D in_volume;\n"
"uniform int in_noOfComponents;\n"
"\n"
"uniform int in_independentComponents;\n"
"\n"
"uniform sampler2D in_noiseSampler;\n"
"uniform sampler2D in_depthSampler;\n"
"\n"
"// Camera position\n"
"uniform vec3 in_cameraPos;\n"
"\n"
"// view and model matrices\n"
"uniform mat4 in_projectionMatrix;\n"
"uniform mat4 in_inverseProjectionMatrix;\n"
"uniform mat4 in_modelViewMatrix;\n"
"uniform mat4 in_inverseModelViewMatrix;\n"
"uniform mat4 in_textureDatasetMatrix;\n"
"uniform mat4 in_inverseTextureDatasetMatrix;\n"
"uniform mat4 in_textureOriginMatrix;\n"
"uniform mat4 in_inverseVolumeMatrix;\n"
"mat4 invTextureOriginMatrix = inverse(in_textureOriginMatrix);\n"
"\n"
"// Ray step size\n"
"uniform vec3 in_cellStep;\n"
"uniform vec2 in_scalarsRange[4];\n"
"uniform vec3 in_cellSpacing;\n"
"\n"
"// Sample distance\n"
"uniform float in_sampleDistance;\n"
"\n"
"// Scales\n"
"uniform vec3 in_cellScale;\n"
"uniform vec2 in_windowLowerLeftCorner;\n"
"uniform vec2 in_inverseOriginalWindowSize;\n"
"uniform vec2 in_inverseWindowSize;\n"
"uniform vec3 in_textureExtentsMax;\n"
"uniform vec3 in_textureExtentsMin;\n"
"\n"
"// scale and shift\n"
"uniform float in_clippingPlanes[49];\n"
"uniform float in_scale;\n"
"uniform float in_bias;\n"
"uniform float in_croppingPlanes[6];\n"
"\n"
"/*===================================VQ===============================*/\n"
"// cropping box coordinate in texture domain\n"
"bool l_skip = false;\n"
"vec4 l_bb_min = vec4(in_croppingPlanes[0], in_croppingPlanes[2], in_croppingPlanes[4], 1.0);"
"\n"
"// Maximum texture access coordinate\n"
"vec4 l_bb_max = vec4(in_croppingPlanes[1], in_croppingPlanes[3], in_croppingPlanes[5], 1.0);\n"
"\n"
"// Material and lighting\n"
"uniform vec3 in_diffuse[4];\n"
"uniform vec3 in_ambient[4];\n"
"uniform vec3 in_specular[4];\n"
"uniform float in_shininess[4];\n"
"uniform vec3 in_lightAmbientColor[1];\n"
"uniform vec3 in_lightDiffuseColor[1];\n"
"uniform vec3 in_lightSpecularColor[1];\n"
"vec4 g_lightPosObj;\n"
"vec3 g_ldir;\n"
"vec3 g_vdir;\n"
"vec3 g_h;\n"
"vec3 g_aspect;\n"
"uniform vec4 in_componentWeight;\n"
"\n"
"uniform float fuseCoef;\n"
"uniform int m_lightonly;\n"
"uniform int m_inverted;\n"
"uniform float mc_weight;\n"
"uniform float mc_threshold;\n"
"uniform float mc_transPeriod;\n"
"uniform vec3 mc_channelWeight;\n"
"uniform sampler2D in_opacityTransferFunc;\n"
"uniform sampler2D in_opacityTransferFunc1;\n"
"uniform sampler2D in_opacityTransferFunc2;\n"
"\n"
"/*===================================VQ===============================*/\n"
"//VQ:variables to support vtkvolume usermatrix\n"
"uniform mat4 in_originMatrix;\n"
"uniform mat4 in_InverseOriginMatrix;\n"
"uniform mat4 in_volumeUserMatrix;\n"
"uniform mat4 in_volumeInvUserMatrix;\n"
"uniform mat4 in_flipMatrix;\n"
"\n"
"vec4 computeOpacity(vec4 scalar) {\n"
"    vec4 opacity = vec4(0.0);\n"
"    opacity.r = texture2D(in_opacityTransferFunc, vec2(scalar.r, 0)).r;\n"
"    opacity.g = texture2D(in_opacityTransferFunc1, vec2(scalar.g, 0)).r;\n"
"    opacity.b = texture2D(in_opacityTransferFunc2, vec2(scalar.b, 0)).r;\n"
"    return opacity;\n"
"}\n"
"\n"
"float computeOpacitySingle(vec4 scalar, int component) {\n"
"    if (component == 0) {\n"
"        return texture2D(in_opacityTransferFunc, vec2(scalar[0], 0)).r;\n"
"    }\n"
"    if (component == 1) {\n"
"        return texture2D(in_opacityTransferFunc1, vec2(scalar[1], 0)).r;\n"
"    }\n"
"    if (component == 2) {\n"
"        return texture2D(in_opacityTransferFunc2, vec2(scalar[2], 0)).r;\n"
"    }\n"
"}\n"
"\n"
"//VQ::RGBRayCastingMethod::GradientDefinition\n"
"\n"
"uniform sampler2D in_colorTransferFunc;\n"
"uniform sampler2D in_colorTransferFunc1;\n"
"uniform sampler2D in_colorTransferFunc2;\n"
"\n"
"vec4 computeColor(vec4 scalar, vec4 opacity) {\n"
"    vec4 color = vec4(1.0);\n"
"    color.r = texture2D(in_colorTransferFunc, vec2(scalar.r,0)).r * opacity.r;\n"
"    color.g = texture2D(in_colorTransferFunc, vec2(scalar.g,0)).r * opacity.g;\n"
"    color.b = texture2D(in_colorTransferFunc, vec2(scalar.b,0)).r * opacity.b;\n"
"    return color;\n"
"}\n"
"\n"
"vec3 computeRayDirection() {\n"
"    return normalize(ip_vertexPos.xyz - g_eyePosObj.xyz);\n"
"}\n"
"\n"
"/*===================================VQ===============================*/\n"
"//VQ:get smoothed volume intensity with mean filter\n"
"vec4 ComputeSmoothVolumeIntensity(vec3 dataPos, int smoothness) {\n"
"    vec4 intensity = vec4(1.0);\n"
"    if (smoothness == 0) {\n"
"        intensity = texture3D(in_volume, dataPos);\n"
"    } else {\n"
"        vec4 sum = vec4(0.0);\n"
"        float cnt = 0.0;\n"
"        for (int i = -smoothness; i <= smoothness; i++) {\n"
"            for (int j = -smoothness; j <= smoothness; j++) {\n"
"                for (int k = -smoothness; k <= smoothness; k++) {\n"
"                    vec3 newPos = vec3(dataPos.x + float(i) * in_cellStep[0], dataPos.y + float(j) * in_cellStep[1], dataPos.z + float(k) * in_cellStep[2]);\n"
"                    intensity = texture3D(in_volume, newPos);\n"
"                    sum += intensity;\n"
"                    cnt += 1.0;\n"
"                }\n"
"            }\n"
"        }\n"
"        intensity = sum / cnt;\n"
"    }\n"
"    intensity = intensity * in_volume_scale + in_volume_bias;\n"
"    return intensity;\n"
"}\n"
"\n"
"/*===================================VQ===============================*/\n"
"//VQ:compute surface gradient\n"
"vec3 ComputeGradientNormal(vec3 dataPos, int smoothness) {\n"
"    vec4 gradientNormal = vec4(0.0);\n"
"    if (dataPos.x <= 0.0 ||\n"
"        dataPos.x >= 1.0 ||\n"
"        dataPos.y <= 0.0 ||\n"
"        dataPos.y >= 1.0 ||\n"
"        dataPos.z <= 0.0 ||\n"
"        dataPos.z >= 1.0) {\n"
"        return gradientNormal.rgb;\n"
"    }\n"
"\n"
"    vec3 direction = vec3(-1.0, 1.0, 1.0); //vec3(-sign(in_cameraPos.x), sign(in_cameraPos.z), sign(in_cameraPos.y));\n"
"    float stepscale = 2.0;\n"
"    for (int i = 0; i < 3; i++) {\n"
"        vec3 g1dataPos = dataPos;\n"
"        g1dataPos[i] = g1dataPos[i] - stepscale * direction[i] * in_cellStep[i];\n"
"        vec3 g2dataPos = dataPos;\n"
"        g2dataPos[i] = g2dataPos[i] + stepscale * direction[i] * in_cellStep[i];\n"
"        vec4 g1 = ComputeSmoothVolumeIntensity(g1dataPos, smoothness);\n"
"        vec4 g2 = ComputeSmoothVolumeIntensity(g2dataPos, smoothness);\n"
"        g1 = g1 * in_volume_scale + in_volume_bias;\n"
"        g2 = g2 * in_volume_scale + in_volume_bias;\n"
"        gradientNormal[i] = length(g2.rgb) - length(g1.rgb);\n"
"    }\n"
"    return gradientNormal.rgb;\n"
"}\n"
"\n"
"/**************************************************************/\n"
"\n"
"const float INV_PI_F = 0.31830988618379067154;\n"
"const float INV_TWO_PI_F = 0.15915494309189533577;\n"
"const float PI_F = 3.141592654;\n"
"\n"
"/*===================================VQ===============================*/\n"
"//VQ:define scatter event, this is the location where light get absored by tissue\n"
"struct scatterEvent {\n"
"    vec3 minT;\n"
"    vec3 pos;\n"
"    vec3 norm;\n"
"    float normWeight;\n"
"    vec3 refRay;\n"
"    int event; //0 for volume, 1 for light, 2 for other object\n"
"    int valid;\n"
"};\n"
"\n"
"/*===================================VQ===============================*/\n"
"//VQ:struct that store shader color\n"
"struct shaderInfo {\n"
"    vec3 norm;\n"
"    vec3 reflectRay;\n"
"    vec4 diffuseColor;\n"
"    vec4 specularColor;\n"
"    vec4 emissionColor;\n"
"    float ior;\n"
"    float glossiness;\n"
"};\n"
"\n"
"/*===================================VQ===============================*/\n"
"//VQ:light information\n"
"struct lightInfo {\n"
"    vec3 surfaceN;\n"
"    vec3 surfaceP;\n"
"    vec3 pos;\n"
"    int type; //0 for point and 1 for plane\n"
"};\n"
"\n"
"/*===================================VQ===============================*/\n"
"//VQ:light information.lightPos is in volume space and eyepos is in world space\n"
"void computeLightNormal() {\n"
"    // Light position in dataset space\n"
"    g_lightPosObj = (in_inverseVolumeMatrix * vec4(in_cameraPos, 1.0));\n"
"    if (g_lightPosObj.w != 0.0) {\n"
"        g_lightPosObj.x /= g_lightPosObj.w;\n"
"        g_lightPosObj.y /= g_lightPosObj.w;\n"
"        g_lightPosObj.z /= g_lightPosObj.w;\n"
"        g_lightPosObj.w = 1.0;\n"
"    }\n"
"    g_ldir = normalize(g_lightPosObj.xyz - ip_vertexPos);\n"
"    g_vdir = normalize(g_eyePosObj.xyz - ip_vertexPos);\n"
"    g_h = normalize(g_ldir + g_vdir);\n"
"};\n"
"\n"
"/*===================================VQ===============================*/\n"
"//VQ:get shader information, it map volume intensity to final color with transfer funciton or texture\n"
"shaderInfo getShader(scatterEvent event) {\n"
"    //define shader information\n"
"    shaderInfo shader;\n"
"    vec4 intensity = texture3D(in_volume, event.pos);\n"
"    intensity = intensity * in_volume_scale + in_volume_bias;\n"
"    shader.emissionColor = computeColor(intensity, vec4(1.0));\n"
"    shader.norm = event.norm;\n"
"    shader.reflectRay = event.refRay;\n"
"    shader.diffuseColor = shader.emissionColor;\n"
"    shader.specularColor = vec4(0.9, 0.9, 0.9, shader.emissionColor.a);\n"
"    shader.ior = 0.5;\n"
"    shader.glossiness = in_shininess[0];\n"
"    return shader;\n"
"}\n"
"\n"
"/*===================================VQ===============================*/\n"
"//VQ:get light info, now only one spot light from camera\n"
"lightInfo getLight() {\n"
"    lightInfo planeLight;\n"
"    planeLight.type = 1;\n"
"    planeLight.surfaceP = g_eyePosObj.xyz;\n"
"    planeLight.surfaceN = g_vdir;\n"
"    return planeLight;\n"
"}\n"
"\n"
"/*===================================VQ===============================*/\n"
"//VQ: shader, compute three lights\n"
"vec4 uniformSampleOneLight(scatterEvent event) {\n"
"    //init shader\n"
"    shaderInfo shader = getShader(event);\n"
"\n"
"    //init light\n"
"    lightInfo planeLight = getLight();\n"
"    vec3 scatterPointtoLight = normalize(planeLight.surfaceP - event.pos);\n"
"\n"
"    //BRDF information\n"
"    vec3 normN = normalize(event.norm);\n"
"    vec3 normU = normalize(cross(event.norm, event.refRay));\n"
"    vec3 normV = normalize(cross(event.norm, normU));\n"
"    vec3 localRefRay = vec3(dot(event.refRay, normU), dot(event.refRay, normV), dot(event.refRay, normN));\n"
"    vec3 localScatterPointtoLight = vec3(dot(scatterPointtoLight, normU), dot(scatterPointtoLight, normV), dot(scatterPointtoLight, normN));\n"
"\n"
"    //diffuse effect\n"
"    float reflactfactor = abs(localScatterPointtoLight.z);\n"
"    vec4 diffuseColor = shader.diffuseColor * (reflactfactor);\n"
"\n"
"    //specular effect\n"
"    float cosThetaO = abs(localRefRay.z);\n"
"    float cosThetaI = abs(localScatterPointtoLight.z);\n"
"    vec4 reflectColor = diffuseColor;\n"
"    float bsfpdf = 0.0;\n"
"    if (cosThetaO * cosThetaI > 0.0) {\n"
"        float lambertianpdf = pow(cosThetaI, 2.0) * INV_PI_F;\n"
"        bsfpdf += lambertianpdf;\n"
"    }\n"
"    if (cosThetaO * cosThetaI > 0.0) {\n"
"        vec3 wh = normalize(localRefRay + localScatterPointtoLight);\n"
"        float cosTheta = abs(dot(localRefRay, localScatterPointtoLight));\n"
"        float microfacepdf = (shader.glossiness) * pow(cosTheta, shader.glossiness) / (2.0 * PI_F * 4.0 * cosTheta);\n"
"        bsfpdf += microfacepdf;\n"
"    }\n"
"    vec4 specularColor = vec4(0.0);\n"
"    if (bsfpdf > 0.0) {\n"
"        float lightpdf = normalize(distance(planeLight.surfaceP, event.pos)) / abs(dot(planeLight.surfaceN, scatterPointtoLight) * 4.0);\n"
"        float weightpdf = lightpdf * lightpdf / (lightpdf * lightpdf + bsfpdf * bsfpdf);\n"
"        weightpdf = 1.0 - weightpdf;\n"
"        specularColor = bsfpdf * abs(dot(scatterPointtoLight, planeLight.surfaceN)) * weightpdf * shader.specularColor;\n"
"    }\n"
"    vec4 finalColor = vec4(in_ambient[0], 1.0) * shader.emissionColor + vec4(in_diffuse[0], 1.0) * diffuseColor + vec4(in_specular[0], 1.0) * specularColor;\n"
"\n"
"    //tone mapping\n"
"    if (false) {\n"
"        float exposure = 0.25;\n"
"        float invexposure = 1.0 / exposure;\n"
"        finalColor = 1.0 - exp(-finalColor * invexposure);\n"
"    }\n"
"    finalColor = clamp(finalColor, vec4(0.0), vec4(1.0));\n"
"    return finalColor;\n"
"}\n"
"\n"
"/*===================================VQ===============================*/\n"
"//VQ:compute the location where light get absored by tissue, now it only store one scatter point\n"
"scatterEvent sampleVolume(vec3 pos, vec3 rayDir, vec3 dirStep) {\n"
"    scatterEvent volumeEvent;\n"
"    volumeEvent.event = 0;\n"
"    volumeEvent.valid = 1;\n"
"\n"
"    float densityScale = 10.0;\n"
"    float energy = 20.0;\n"
"    float remainEnergy = 0.0;\n"
"    float sigmaT = 0.0;\n"
"    int cnt = 0;\n"
"    bool stop = false;\n"
"    vec4 normalizedIntensity = vec4(1.0);\n"
"\n"
"    const vec3 tex_min = vec3(0);\n"
"    const vec3 tex_max = vec3(1);\n"
"\n"
"    while (remainEnergy < energy && !stop) {\n"
"        l_skip = dot(sign(pos - l_bb_min.xyz), sign(l_bb_max.xyz - pos)) < 3.0;\n"
"        vec4 intensity = texture3D(in_volume, pos);\n"
"        intensity = intensity * in_volume_scale + in_volume_bias;\n"
"        vec4 opacity = computeOpacity(intensity);\n"
"        if(!l_skip) {normalizedIntensity = intensity;\n"
"        sigmaT = length(opacity) * densityScale;\n"
"        remainEnergy += sigmaT;}\n"
"        float zoomStepRate = clamp(in_sampleDistance * densityScale * 10.0 * length(opacity), 1.0, 20.0);\n"
"        pos += dirStep / zoomStepRate;\n"
"        stop = dot(sign(pos - tex_min), sign(tex_max - pos)) < 3.0;\n"
"        cnt++;\n"
"    }\n"
"    vec3 norm = ComputeGradientNormal(pos, 2);\n"
"    norm = norm.xyz / in_cellSpacing;\n"
"    volumeEvent.pos = pos;\n"
"    volumeEvent.norm = normalize(norm);\n"
"    volumeEvent.normWeight = length(normalizedIntensity);\n"
"    volumeEvent.refRay = normalize(rayDir - 2.0 * (dot(rayDir, volumeEvent.norm)) * volumeEvent.norm);\n"
"    return volumeEvent;\n"
"}\n"
"\n"
"scatterEvent intersectLights(vec3 ray) {\n"
"    scatterEvent lightEvent;\n"
"    lightEvent.event = 1;\n"
"    lightEvent.valid = 0;\n"
"\n"
"    return lightEvent;\n"
"}\n"
"\n"
"scatterEvent intersectObject(vec3 pos, vec3 rayDir, int totalSamplePoint) {\n"
"    scatterEvent objectEvent;\n"
"    objectEvent.event = 2;\n"
"    if (totalSamplePoint > 0) {\n"
"        objectEvent.valid = 1;\n"
"        objectEvent.pos = pos + rayDir * float(totalSamplePoint);\n"
"    } else {\n"
"        objectEvent.valid = 0;\n"
"    }\n"
"    objectEvent.valid = 0;\n"
"    return objectEvent;\n"
"}\n"
"\n"
"/*===================================VQ===============================*/\n"
"//VQ:test ray intercept with either volume, light, or object, now only volume\n"
"scatterEvent sampleRay(vec3 pos, vec3 rayDir, vec3 dirStep, int totalObjectSamplePoint) {\n"
"\n"
"    scatterEvent event[3];\n"
"    event[0] = sampleVolume(pos, rayDir, dirStep);\n"
"    event[1] = intersectLights(pos);\n"
"    event[2] = intersectObject(pos, rayDir, totalObjectSamplePoint);\n"
"\n"
"    int idx = -1;\n"
"    vec3 intersect = vec3(1.0);\n"
"    for (int i = 0; i < 3; i++) {\n"
"        if (event[i].valid == 1 && (length(event[i].pos) < length(intersect))) {\n"
"            idx = i;\n"
"        }\n"
"    }\n"
"    if (idx < 3 && idx >= 0) {\n"
"        return event[idx];\n"
"    } else {\n"
"        scatterEvent invalidEvent;\n"
"        invalidEvent.valid = 0;\n"
"        return invalidEvent;\n"
"    }\n"
"}\n"
"\n"
"/*===================================VQ===============================*/\n"
"//VQ: select scatter position\n"
"vec4 singleScattering(vec3 pos, vec3 rayDir, vec3 dirStep, int totalObjectSamplePoint) {\n"
"    scatterEvent event = sampleRay(pos, rayDir, dirStep, totalObjectSamplePoint);\n"
"\n"
"    vec4 color = vec4(0.0);\n"
"    if (event.valid == 1 && event.event == 0) { // volume\n"
"        color += uniformSampleOneLight(event);\n"
"    }\n"
"    if (event.valid == 1 && event.event == 1) { // light\n"
"        //color += vec4(0.9);\n"
"    }\n"
"    if (event.valid == 1 && event.event == 2) { // object\n"
"        //color += computeLightShadingColor(event.pos, 1);\n"
"    }\n"
"\n"
"    color.a = 1.0;\n"
"    return color;\n"
"}\n"
"\n"
"/**************************************************************/\n"
"\n"
"void main() {\n"
"    /// Initialize g_fragColor (output) to 0\n"
"    g_fragColor = vec4(0.0);\n"
"    g_dirStep = vec3(0.0);\n"
"    g_srcColor = vec4(0.0);\n"
"    g_exit = false;\n"
"\n"
"/*compute bounding box minmax coordinate in texture domain*/"
"    l_bb_min = in_inverseTextureDatasetMatrix * l_bb_min;\n"
"    if (l_bb_min.w != 0.0)\n"
"    {\n"
"       l_bb_min.x /= l_bb_min.w;\n"
"       l_bb_min.y /= l_bb_min.w;\n"
"       l_bb_min.z /= l_bb_min.w;\n"
"       l_bb_min.w = 1.0;\n"
"    }\n"
"    l_bb_max = in_inverseTextureDatasetMatrix * l_bb_max;\n"
"    if (l_bb_max.w != 0.0)\n"
"    {\n"
"       l_bb_max.x /= l_bb_max.w;\n"
"       l_bb_max.y /= l_bb_max.w;\n"
"       l_bb_max.z /= l_bb_max.w;\n"
"       l_bb_max.w = 1.0;\n"
"    }\n"
"    // Get the 3D texture coordinates for lookup into the in_volume dataset\n"
"    vec4 texremapped = vec4(ip_textureCoords, 1.0);\n"
"    texremapped = invTextureOriginMatrix * in_flipMatrix * in_textureOriginMatrix * texremapped;\n"
"    g_dataPos = texremapped.xyz;\n"
"\n"
"    // Eye position in object space\n"
"    g_eyePosObj = (in_InverseOriginMatrix * in_volumeInvUserMatrix * in_originMatrix * vec4(in_cameraPos, 1.0));\n"
"    if (g_eyePosObj.w != 0.0) {\n"
"        g_eyePosObj.x /= g_eyePosObj.w;\n"
"        g_eyePosObj.y /= g_eyePosObj.w;\n"
"        g_eyePosObj.z /= g_eyePosObj.w;\n"
"        g_eyePosObj.w = 1.0;\n"
"    }\n"
"\n"
"    // Getting the ray marching direction (in object space);\n"
"    vec3 rayDir = computeRayDirection();\n"
"\n"
"    g_dirStep = (in_inverseTextureDatasetMatrix * invTextureOriginMatrix * in_flipMatrix * in_textureOriginMatrix * vec4(rayDir, 0.0)).xyz * in_sampleDistance;\n"
"\n"
"    g_dataPos += g_dirStep * (texture2D(in_noiseSampler, g_dataPos.xy).x);\n"
"\n"
"    vec2 fragTexCoord = (gl_FragCoord.xy - in_windowLowerLeftCorner) * in_inverseWindowSize;\n"
"    vec4 l_depthValue = texture2D(in_depthSampler, fragTexCoord);\n"
"    float l_terminatePointMax = 0.0;\n"
"\n"
"    // Depth test\n"
"    if (gl_FragCoord.z >= l_depthValue.x) {\n"
"        discard;\n"
"    }\n"
"\n"
"    vec4 terminatePoint;\n"
"    terminatePoint.x = (gl_FragCoord.x - in_windowLowerLeftCorner.x) * 2.0 * in_inverseWindowSize.x - 1.0;\n"
"    terminatePoint.y = (gl_FragCoord.y - in_windowLowerLeftCorner.y) * 2.0 * in_inverseWindowSize.y - 1.0;\n"
"    terminatePoint.z = (2.0 * l_depthValue.x - (gl_DepthRange.near + gl_DepthRange.far)) / gl_DepthRange.diff;\n"
"    terminatePoint.w = 1.0;\n"
"\n"
"    terminatePoint = in_inverseTextureDatasetMatrix *\n"
"        in_originMatrix * in_volumeInvUserMatrix * in_InverseOriginMatrix * in_inverseModelViewMatrix * in_inverseProjectionMatrix * terminatePoint;\n"
"    terminatePoint /= terminatePoint.w;\n"
"    l_terminatePointMax = length(terminatePoint.xyz - ip_textureCoords.xyz) / length(g_dirStep);\n"
"\n"
"    // We get data between 0.0 - 1.0 range\n"
"    computeLightNormal();\n"
"\n"
"    // For all samples along the ray\n"
"    g_srcColor = singleScattering(g_dataPos, rayDir, g_dirStep, int(l_terminatePointMax));\n"
"\n"
"    g_fragColor = g_srcColor;\n"
"\n"
"    g_fragColor.r = g_fragColor.r * in_scale + in_bias * g_fragColor.a;\n"
"    g_fragColor.g = g_fragColor.g * in_scale + in_bias * g_fragColor.a;\n"
"    g_fragColor.b = g_fragColor.b * in_scale + in_bias * g_fragColor.a;\n"
"    gl_FragData[0] = g_fragColor;\n"
"\n"
"}\n";
#endif
