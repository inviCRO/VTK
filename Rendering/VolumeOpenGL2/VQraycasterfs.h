#ifndef VQRAYCASTERFS2_H
#define VQRAYCASTERFS2_H

#include <string>



std::string RGBGradientDefination() {
    return std::string("\n"
                       "uniform sampler3D in_gradient;\n"
                       "\n"
                       " uniform sampler2D in_gradientTransferFunc;\n"
                       " uniform sampler2D in_gradientTransferFunc1;\n"
                       " uniform sampler2D in_gradientTransferFunc2;        \n"
                       "float computeGradientOpacity(vec4 grad, int component)        \n"
                       "  {        \n"
                       "  if (component == 0)        \n"
                       "    {        \n"
                       "    return texture2D(in_gradientTransferFunc, vec2(grad.r, 0.0)).r;        \n"
                       "    }        \n"
                       "  if (component == 1)        \n"
                       "    {        \n"
                       "    return texture2D(in_gradientTransferFunc1, vec2(grad.g, 0.0)).r;        \n"
                       "    }        \n"
                       "  if (component == 2)        \n"
                       "    {        \n"
                       "    return texture2D(in_gradientTransferFunc2, vec2(grad.b, 0.0)).r;        \n"
                       "    }        \n"
                       "  }        \n"
                       "\n");
}

std::string GradientDefination() {
    return std::string("\n"
                       "uniform sampler3D in_gradient;\n"
                       "\n"
                       "uniform sampler2D in_gradientTransferFunc;\n"
                       "vec4 computeGradientIntensity() {\n"
                       "    vec4 gradient = texture3D(in_gradient, g_dataPos);\n"
                       "    gradient = vec4(gradient.r,gradient.r,gradient.r,gradient.r);\n"
                       "    return gradient;\n"
                       "}\n"
                       "float computeGradientOpacity(vec4 grad, int component)\n"
                       "{\n"
                       "    return texture2D(in_gradientTransferFunc, vec2(grad.w, 0.0)).r;\n"
                       "}\n"
                       "\n");
}

std::string noGradientDefination() {
    return std::string("\n"
                       "vec4 computeGradientIntensity() {\n"
                       "    return vec4(1.0);\n"
                       "}\n"
                       "float computeGradientOpacity(vec4 grad, int component)\n"
                       "{\n"
                       "    return 1.0;\n"
                       "}\n"
                       "\n");
}

std::string RGBColorProjection() {
            return std::string("    vec4 scalar = texture3D(in_volume, g_dataPos);\n"
                "        scalar = scalar*in_volume_scale + in_volume_bias;\n"
                "        float distance = 0.0;\n"
                "        for(int idx = 0; idx < 3; idx++) {\n"
                "            distance += pow( scalar[idx] - mc_channelWeight[idx]/255, 2.0);\n"
                "        }\n"
                "        distance = sqrt(distance)/1.732;\n"
                "        float op = 1.0 - distance * mc_transPeriod;\n"
                "        if(op < 0.0) op = 0.0;\n if(op > 1.0) op = 1.0;\n"
                "        scalar.rgb = scalar.rgb * op;\n"
                "        if (op > mc_threshold){"
                "           if (!g_skip){ l_sampledValue += scalar * remainOpacity;}\n"
                "           remainOpacity *= (1.0 - op);\n"
                "        }\n"
                "        if (remainOpacity < 0.01)\n"
                "        {\n"
                "            break;\n"
                "        }\n"
                "        if (l_firstValue)\n"
                "        {\n"
                "            l_firstValue = false;\n"
                "        }\n"
                "\n"
                "        g_dataPos += g_dirStep;\n"
                "\n"
                "        stop = dot(sign(g_dataPos - l_tex_min), sign(l_tex_max - g_dataPos)) < 3.0;\n"
                "        if (stop)\n"
                "        {\n"
                "            break;\n"
                "        }\n"
                "\n"
                "        if(l_currentT >= l_terminatePointMax)\n"
                "        {\n"
                "            break;\n"
                "       }\n"
                "        l_currentT+= 1.0;\n");
}

std::string AutoRGBCompositeProjection() {
    return std::string("        vec4 scalar = texture3D(in_volume, g_dataPos);\n"
                       "        vec4 gradient = texture3D(in_gradient, g_dataPos);\n"
                       "        scalar = scalar*in_volume_scale + in_volume_bias;\n"
                       "        float scalarSum = scalar.r * mc_channelWeight.r + scalar.g * mc_channelWeight.g + scalar.b * mc_channelWeight.b;\n"
                       "        scalarSum /= 3.0;\n"
                       "        float gradientSum = gradient.r + gradient.g + gradient.b;\n"
                       "        gradientSum /= 3.0;\n"
                       "        gradientSum *= 2;\n"
                       "        if(gradientSum > 1.0) {\n"
                       "            gradientSum = 1.0;\n"
                       "        }\n"
                       "        float pow = (mc_weight * scalarSum + (1 - mc_weight) * gradientSum) - mc_threshold;\n"
                       "        float op = 1.0 / (1.0 + exp(mc_transPeriod * pow));\n"
                       "        if(m_inverted > 0) {op *=  (1.0 - scalarSum);}\n"
                       "        else {op *= scalarSum;}\n"
                       "        scalar.rgb = scalar.rgb * op;\n"
                       "        if(!g_skip) {l_sampledValue += scalar * remainOpacity;}\n"
                       "        remainOpacity *= (1.0 - op);\n"
                       "        if (remainOpacity < 0.01)\n"
                       "        {\n"
                       "            break;\n"
                       "        }\n"
                       "        if (l_firstValue)\n"
                       "        {\n"
                       "            l_firstValue = false;\n"
                       "        }\n"
                       "\n"
                       "        g_dataPos += g_dirStep;\n"
                       "\n"
                       "        stop = dot(sign(g_dataPos - l_tex_min), sign(l_tex_max - g_dataPos)) < 3.0;\n"
                       "        if (stop)\n"
                       "        {\n"
                       "            break;\n"
                       "        }\n"
                       "\n"
                       "        if(l_currentT >= l_terminatePointMax)\n"
                       "        {\n"
                       "            break;\n"
                       "       }\n"
                       "        l_currentT+= 1.0;\n");
}

std::string AlphaRGBCompositeProjection() {
    return std::string("        vec4 scalar = texture3D(in_volume, g_dataPos);\n"
                       "        vec4 gradient = texture3D(in_gradient, g_dataPos);\n"
                       "        scalar = scalar*in_volume_scale + in_volume_bias;\n"
                       "        vec4 gradientOpacity = vec4(0.0);\n"
                       "        vec4 scalarOpacity = vec4(0.0);\n"
                       "        if (l_firstValue)\n"
                       "        {\n"
                       "            gradient = vec4(0.0);\n"
                       "        }\n"
                       "        \n"
                       "        float totalAlpha = 0.0;\n"
                       "        vec4 tmpAlpha = vec4(0.0);\n"
                       "        for(int i = 0; i < in_noOfComponents; i++){\n"
                       "            scalarOpacity[i] = computeOpacity(scalar,i);\n"
                       "            gradientOpacity[i] = computeGradientOpacity(gradient,i);\n"
                       "        }\n"
                       "        for (int i = 0; i < in_noOfComponents; ++i)\n"
                       "        {\n"
                       "             tmpAlpha[i] = scalarOpacity[i] * gradientOpacity[i];\n"
                       "             totalAlpha += scalarOpacity[i] * gradientOpacity[i];\n"
                       "        }\n"
                       "        if(totalAlpha > 0 && !g_skip) { \n"
                       "            for (int i = 0; i < in_noOfComponents; ++i)\n"
                       "            {\n"
                       "                vec4 tmpcolor = computeColor(scalar, 1.0, i);\n;\n"
                       "                l_sampledValue[0] += tmpcolor[0] * tmpAlpha[i];\n"
                       "                l_sampledValue[1] += tmpcolor[1] * tmpAlpha[i];\n"
                       "                l_sampledValue[2] += tmpcolor[2] * tmpAlpha[i];\n"
                       "                l_sampledValue[3] += tmpAlpha[i] * tmpAlpha[i] / totalAlpha;\n"
                       "            }\n"
                       "        }\n"
                       "        remainOpacity *= 1 - l_sampledValue[3];\n "
                       "        if (remainOpacity < 0.01)\n"
                       "        {\n"
                       "            break;\n"
                       "        }\n"
                       "        if (l_firstValue)\n"
                       "        {\n"
                       "            l_firstValue = false;\n"
                       "        }\n"
                       "\n"
                       "        g_dataPos += g_dirStep;\n"
                       "\n"
                       "        stop = dot(sign(g_dataPos - l_tex_min), sign(l_tex_max - g_dataPos)) < 3.0;\n"
                       "        if (stop)\n"
                       "        {\n"
                       "            break;\n"
                       "        }\n"
                       "\n"
                       "        if(l_currentT >= l_terminatePointMax)\n"
                       "        {\n"
                       "            break;\n"
                       "        }\n"
                       "        l_currentT+= 1.0;\n");
}

std::string AlphaCompositeProjection() { //l)maxValue in this function will contains the blended pixel value
    return std::string(    
        "        vec4 scalar = texture3D(in_volume, g_dataPos);\n"
        "        scalar.r = scalar.r*in_volume_scale.r + in_volume_bias.r;\n"
        "        scalar = vec4(scalar.r,scalar.r,scalar.r,scalar.r);\n"
        "        float scalarOpacity = computeOpacity(scalar);\n"
        "        vec4 gradient = computeGradientIntensity();\n"
        "        float gradientOpacity = computeGradientOpacity(gradient, 0);\n"
        "        vec4 tmpcolor = vec4(0); tmpcolor.w = scalar.r; \n"
        "        if(scalarOpacity * gradientOpacity > 0 && !g_skip) {\n   "
        "           vec4 temcolor = computeColor(tmpcolor, 1.0);"
        "           temcolor.rgb = temcolor.rgb * scalarOpacity * gradientOpacity;\n"
        "           l_sampledValue += temcolor * remainOpacity;\n"
        "           remainOpacity *= (1- scalarOpacity * gradientOpacity);\n"
        "        }\n"
        "        if (remainOpacity < 0.01)\n"
        "        {\n"
        "            break;\n"
        "        }\n"
        "\n"
        "        if (l_firstValue)\n"
        "        {\n"
        "            l_firstValue = false;\n"
        "        }\n"
        "\n"
        "        g_dataPos += g_dirStep;\n"
        "\n"
        ""
        "        stop = dot(sign(g_dataPos - l_tex_min), sign(l_tex_max - g_dataPos)) < 3.0;\n"
        "        if (stop)\n"
        "        {\n"
        "            break;\n"
        "        }\n"
        "\n"
        "        if(l_currentT >= l_terminatePointMax)\n"
        "        {\n"
        "            break;\n"
        "       }\n"
        "        l_currentT+= 1.0;\n");
}

std::string AutoCompositeProjection() {
    return std::string("        vec4 scalar = texture3D(in_volume, g_dataPos);"
                       "\n      scalar.r = scalar.r*in_volume_scale.r + in_volume_bias.r;"
                       "\n      scalar = vec4(scalar.r,scalar.r,scalar.r,scalar.r);"
                       "\n      vec4 gradient = texture3D(in_gradient, g_dataPos);"
                       "\n      gradient = vec4(gradient.r,gradient.r,gradient.r,gradient.r);"
                       "\n      if (l_firstValue)"
                       "\n      {"
                       "\n          gradient = vec4(0.0);"
                       "\n      }"
                       "\n      float weighttmp = (mc_weight * scalar.w) + (1.0-mc_weight) * gradient.r;"
                       "\n      float thredweight = weighttmp - mc_threshold;"
                       "\n      float opacity = 1.0 / (1.0 + exp(mc_transPeriod * thredweight));"
                       "\n      vec4 tmpcolor = vec4(0); tmpcolor.w = scalar.r; "
                       "\n      vec4 temcolor = computeColor(tmpcolor, 1.0);"
                       "\n      temcolor.rgb = temcolor.rgb * opacity;"
                       "\n      if(!g_skip)"
                       "\n      {"
                       "\n          l_sampledValue += temcolor * remainOpacity;"
                       "\n      }"
                       "\n      remainOpacity *= 1- opacity;"
                       "\n"
                       "\n      if (remainOpacity < 0.01)"
                       "\n      {"
                       "\n          break;"
                       "\n      }"
                       "\n      if (l_firstValue)"
                       "\n      {\n"
                       "\n          l_firstValue = false;"
                       "\n      }"
                       "\n"
                       "\n      g_dataPos += g_dirStep;"
                       "\n"
                       "\n      stop = dot(sign(g_dataPos - l_tex_min), sign(l_tex_max - g_dataPos)) < 3.0;"
                       "\n      if (stop)"
                       "\n      {"
                       "\n          break;"
                       "\n      }"
                       "\n"
                       "\n      if(l_currentT >= l_terminatePointMax)"
                       "\n      {"
                       "\n          break;"
                       "\n      }"
                       "\n      l_currentT+= 1.0;");
}

const char* RGBraycasterfsEx = "//VTK::System::Dec\n"
"\n"
"varying vec3 ip_textureCoords;\n"
"varying vec3 ip_vertexPos;\n"
"\n"
"vec4 g_fragColor = vec4(0.0);\n"
"\n"
"vec3 g_dataPos;\n"
"vec3 g_dirStep;\n"
"vec4 g_srcColor;\n"
"vec4 g_eyePosObj;\n"
"bool g_exit;\n"
"bool g_skip;\n"
"\n"
"uniform vec4 in_volume_scale;\n"
"uniform vec4 in_volume_bias;\n"
"\n"
"uniform float fuseCoef;\n"
"uniform int m_lightonly;\n"
"uniform int m_inverted;\n"
"uniform float mc_weight;\n"
"uniform float mc_threshold;\n"
"uniform float mc_transPeriod;\n"
"uniform vec3 mc_channelWeight;\n"
"\n"
"//VTK::Output::Dec\n"
"\n"
"//VTK::Base::Dec\n"
"\n"
"//VTK::Cropping::Dec\n"
"\n"
"//VTK::Clipping::Dec\n"
"\n"
"//VTK::Shading::Dec\n"
"\n"
"//VTK::BinaryMask::Dec\n"
"\n"
"//VTK::CompositeMask::Dec\n"
"\n"
"//VTK::ComputeOpacity::Dec\n"
"\n"
" //VQ::RGBRayCastingMethod::GradientDefinition "
"\n"
"//VTK::ComputeGradient::Dec\n"
"\n"
"//VTK::ComputeLighting::Dec\n"
"\n"
"//VQ::RGBRayCastingMethod::LightDefinition\n"
"\n"
"//VTK::ComputeColor::Dec\n"
"\n"
"//VTK::ComputeRayDirection::Dec\n"
"\n"
"//VTK::Picking::Dec\n"
"\n"
"//VTK::RenderToImage::Dec\n"
"\n"
"//VTK::DepthPeeling::Dec\n"
"\n"
"uniform float in_clippingPlanes[49];\n"
"uniform float in_scale;\n"
"uniform float in_bias;\n"
"\n"
"//////////////////////////////////////////////////////////////////////////////\n"
"///\n"
"/// Helper functions\n"
"///\n"
"//////////////////////////////////////////////////////////////////////////////\n"
"\n"
"/**\n"
" * Transform window coordinate to NDC.\n"
" */\n"
"vec4 WindowToNDC(const float xCoord, const float yCoord, const float zCoord)\n"
"{\n"
"  vec4 NDCCoord = vec4(0.0, 0.0, 0.0, 1.0);\n"
"\n"
"  NDCCoord.x = (xCoord - in_windowLowerLeftCorner.x) * 2.0 *\n"
"    in_inverseWindowSize.x - 1.0;\n"
"  NDCCoord.y = (yCoord - in_windowLowerLeftCorner.y) * 2.0 *\n"
"    in_inverseWindowSize.y - 1.0;\n"
"  NDCCoord.z = (2.0 * zCoord - (gl_DepthRange.near + gl_DepthRange.far)) /\n"
"    gl_DepthRange.diff;\n"
"\n"
"  return NDCCoord;\n"
"}\n"
"\n"
"/**\n"
" * Transform NDC coordinate to window coordinates.\n"
" */\n"
"vec4 NDCToWindow(const float xNDC, const float yNDC, const float zNDC)\n"
"{\n"
"  vec4 WinCoord = vec4(0.0, 0.0, 0.0, 1.0);\n"
"\n"
"  WinCoord.x = (xNDC + 1.f) / (2.f * in_inverseWindowSize.x) +\n"
"    in_windowLowerLeftCorner.x;\n"
"  WinCoord.y = (yNDC + 1.f) / (2.f * in_inverseWindowSize.y) +\n"
"    in_windowLowerLeftCorner.y;\n"
"  WinCoord.z = (zNDC * gl_DepthRange.diff +\n"
"    (gl_DepthRange.near + gl_DepthRange.far)) / 2.f;\n"
"\n"
"  return WinCoord;\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"    /// Initialize g_fragColor (output) to 0\n"
"    g_fragColor = vec4(0.0);\n"
"    g_dirStep = vec3(0.0);\n"
"    g_srcColor = vec4(0.0);\n"
"    g_exit = false;\n"
"\n"
"//VTK::Base::Init"
"\n"
"//VTK::Terminate::Init"
"\n"
"//VTK::Shading::Init"
"\n"
"//VTK::Cropping::Init"
"\n"
"//VTK::Clipping::Init\n"
"\n"
"//VTK::RenderToImage::Init\n"
"\n"
"//VTK::DepthPass::Init\n"
"\n"
"    // For all samples along the ray\n"
"while (true)\n"
"{\n"
"\n"
" //VTK::Base::Impl"
"\n"
" //VTK::Cropping::Impl"
"\n"
"    //VTK::Clipping::Impl\n"
"\n"
"    //VTK::BinaryMask::Impl\n"
"\n"
"    //VTK::CompositeMask::Impl\n"
"\n"
" //VQ::RGBRayCastingMethod::Implementation"
"\n"
"    //VTK::Shading::Impl\n"
"\n"
"    //VTK::RenderToImage::Impl\n"
"\n"
"    //VTK::DepthPass::Impl\n"
"\n"
"    //VTK::Terminate::Impl\n"
"\n"
"}\n"
"//VTK::Shading::Exit"
"\n"
"    g_fragColor.r = g_fragColor.r * in_scale + in_bias * g_fragColor.a;\n"
"    g_fragColor.g = g_fragColor.g * in_scale + in_bias * g_fragColor.a;\n"
"    g_fragColor.b = g_fragColor.b * in_scale + in_bias * g_fragColor.a;\n"
"    if(m_lightonly == 0) {\n"
"        g_fragColor.a = fuseCoef;\n"
"    } else {\n"
"        g_fragColor.a = (g_fragColor.r + g_fragColor.g + g_fragColor.b)/3;\n"
"    }\n"
"    gl_FragData[0] = g_fragColor;\n"
"\n"
"}\n";

const char* raycasterfsEx = "//VTK::System::Dec\n"
"\n"
"varying vec3 ip_textureCoords;\n"
"varying vec3 ip_vertexPos;\n"
"\n"
"vec4 g_fragColor = vec4(0.0);\n"
"\n"
"vec3 g_dataPos;\n"
"vec3 g_dirStep;\n"
"vec4 g_srcColor;\n"
"vec4 g_eyePosObj;\n"
"bool g_exit;\n"
"bool g_skip;\n"
"\n"
"float g_currentT;\n"
"float g_terminatePointMax;\n"
"\n"
"uniform vec4 in_volume_scale;\n"
"uniform vec4 in_volume_bias;\n"
"\n"
"uniform float fuseCoef;\n"
"uniform int m_lightonly;\n"
"uniform int m_inverted;\n"
"uniform float mc_weight;\n"
"uniform float mc_threshold;\n"
"uniform float mc_transPeriod;\n"
"uniform vec3 mc_channelWeight;\n"
"\n"
"//VTK::Output::Dec\n"
"\n"
"//VTK::Base::Dec\n"
"\n"
"//VTK::Cropping::Dec\n"
"\n"
"//VTK::Clipping::Dec\n"
"\n"
"//VTK::Shading::Dec\n"
"\n"
"//VTK::BinaryMask::Dec\n"
"\n"
"//VTK::CompositeMask::Dec\n"
"\n"
"//VTK::ComputeOpacity::Dec\n"
"\n"
"//VQ::RayCastingMethod::GradientDefinition "
"\n"
"//VTK::ComputeGradient::Dec"
"\n"
"//VTK::ComputeLighting::Dec\n"
"\n"
"//VQ::RayCastingMethod::LightDefinition\n"
"\n"
"//VTK::ComputeColor::Dec\n"
"\n"
"//VTK::ComputeRayDirection::Dec\n"
"\n"
"//VTK::Picking::Dec\n"
"\n"
"//VTK::RenderToImage::Dec\n"
"\n"
"//VTK::DepthPeeling::Dec\n"
"\n"
"uniform float in_clippingPlanes[49];\n"
"uniform float in_scale;\n"
"uniform float in_bias;\n"
"\n"
"//////////////////////////////////////////////////////////////////////////////\n"
"///\n"
"/// Helper functions\n"
"///\n"
"//////////////////////////////////////////////////////////////////////////////\n"
"\n"
"/**\n"
" * Transform window coordinate to NDC.\n"
" */\n"
"vec4 WindowToNDC(const float xCoord, const float yCoord, const float zCoord)\n"
"{\n"
"  vec4 NDCCoord = vec4(0.0, 0.0, 0.0, 1.0);\n"
"\n"
"  NDCCoord.x = (xCoord - in_windowLowerLeftCorner.x) * 2.0 *\n"
"    in_inverseWindowSize.x - 1.0;\n"
"  NDCCoord.y = (yCoord - in_windowLowerLeftCorner.y) * 2.0 *\n"
"    in_inverseWindowSize.y - 1.0;\n"
"  NDCCoord.z = (2.0 * zCoord - (gl_DepthRange.near + gl_DepthRange.far)) /\n"
"    gl_DepthRange.diff;\n"
"\n"
"  return NDCCoord;\n"
"}\n"
"\n"
"/**\n"
" * Transform NDC coordinate to window coordinates.\n"
" */\n"
"vec4 NDCToWindow(const float xNDC, const float yNDC, const float zNDC)\n"
"{\n"
"  vec4 WinCoord = vec4(0.0, 0.0, 0.0, 1.0);\n"
"\n"
"  WinCoord.x = (xNDC + 1.f) / (2.f * in_inverseWindowSize.x) +\n"
"    in_windowLowerLeftCorner.x;\n"
"  WinCoord.y = (yNDC + 1.f) / (2.f * in_inverseWindowSize.y) +\n"
"    in_windowLowerLeftCorner.y;\n"
"  WinCoord.z = (zNDC * gl_DepthRange.diff +\n"
"    (gl_DepthRange.near + gl_DepthRange.far)) / 2.f;\n"
"\n"
"  return WinCoord;\n"
"}\n"
"\n"
"// //////////////////////////////////////////////////////////////////////////////\n"
"//  /// Main\n"
"//  //////////////////////////////////////////////////////////////////////////////\n"
"void main()\n"
"{\n"
"    /// Initialize g_fragColor (output) to 0\n"
"    g_fragColor = vec4(0.0);\n"
"    g_dirStep = vec3(0.0);\n"
"    g_srcColor = vec4(0.0);\n"
"    g_exit = false;\n"
"\n"
"//VTK::Base::Init"
"\n"
"//VTK::Terminate::Init"
"\n"
"//VTK::Shading::Init"
"\n"
"//VTK::Cropping::Init"
"\n"
"//VTK::Clipping::Init\n"
"\n"
"//VTK::RenderToImage::Init\n"
"\n"
"//VTK::DepthPass::Init\n"
"\n"
"// For all samples along the ray\n"
"while (true)\n"
"{\n"
"\n"
" //VTK::Base::Impl"
"\n"
" //VTK::Cropping::Impl"
"\n"
"    //VTK::Clipping::Impl\n"
"\n"
"    //VTK::BinaryMask::Impl\n"
"\n"
"    //VTK::CompositeMask::Impl\n"
"\n"
" //VQ::RayCastingMethod::Implementation"
"\n"
"    //VTK::Shading::Impl\n"
"\n"
"    //VTK::RenderToImage::Impl\n"
"\n"
"    //VTK::DepthPass::Impl\n"
"\n"
"    //VTK::Terminate::Impl\n"
"\n"
"}\n"
"//VTK::Shading::Exit"
"\n"
"    g_fragColor.r = g_fragColor.r * in_scale + in_bias * g_fragColor.a;\n"
"    g_fragColor.g = g_fragColor.g * in_scale + in_bias * g_fragColor.a;\n"
"    g_fragColor.b = g_fragColor.b * in_scale + in_bias * g_fragColor.a;\n"
"    if(m_lightonly == 0) {\n"
"        g_fragColor.a = fuseCoef;\n"
"    } else {\n"
"        g_fragColor.a = (g_fragColor.r + g_fragColor.g + g_fragColor.b)/3;\n"
"    }\n"
"\n"
"    gl_FragData[0] = g_fragColor;\n"
"\n"
"}\n";

#endif // VQRAYCASTERFS2_H
