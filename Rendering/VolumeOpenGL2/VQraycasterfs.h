#ifndef VQRAYCASTERFS2_H
#define VQRAYCASTERFS2_H

#include <string>

std::string noLightShading() {
    return std::string(
                "\n"
                "vec4 computeLighting(vec4 color, int c)"
                "{\n"
                "    return color;\n"
                "}\n"
                "\n");
}

//this code is taken from vtkVolumeShaderComposer.h
std::string lightShading() {
    return std::string(
                "vec4 computeGradient(int c)\n"
                "  {\n"
                "  // Approximate Nabla(F) derivatives with central differences.\n"
                "  vec3 g1; // F_front\n"
                "  vec3 g2; // F_back\n"
                "  g1.x = texture3D(in_volume, vec3(g_dataPos - vec3(in_cellStep[0], 0.0, 0.0)))[c];\n"
                "  g1.y = texture3D(in_volume, vec3(g_dataPos + vec3(0.0, in_cellStep[1], 0.0)))[c];\n"
                "  g1.z = texture3D(in_volume, vec3(g_dataPos + vec3(0.0, 0.0, in_cellStep[2])))[c];\n"
                "  g2.x = texture3D(in_volume, vec3(g_dataPos + vec3(in_cellStep[0], 0.0, 0.0)))[c];\n"
                "  g2.y = texture3D(in_volume, vec3(g_dataPos - vec3(0.0, in_cellStep[1], 0.0)))[c];\n"
                "  g2.z = texture3D(in_volume, vec3(g_dataPos - vec3(0.0, 0.0, in_cellStep[2])))[c];\n"
                "\n"
                "  // Apply scale and bias to the fetched values.\n"
                "  g1 = g1 * in_volume_scale[c] + in_volume_bias[c];\n"
                "  g2 = g2 * in_volume_scale[c] + in_volume_bias[c];\n"
                "\n"
                "  // Central differences: (F_front - F_back) / 2h\n"
                "  // This version of computeGradient() is only used for lighting\n"
                "  // calculations (only direction matters), hence the difference is\n"
                "  // not scaled by 2h and a dummy gradient mag is returned (-1.).\n"
                "  return vec4((g1 - g2), -1.0);\n"
                "  }\n"
                "\n"
                "vec4 computeLighting(vec4 color, int component)\n"
                "  {\n"
                "  vec4 finalColor = vec4(0.0);"
                "  // Compute gradient function only once\n"
                "  vec4 gradient = computeGradient(component);"
                "  vec3 diffuse = vec3(0.0);\n"
                "  vec3 specular = vec3(0.0);\n"
                "  vec3 normal = gradient.xyz / in_cellSpacing;\n"
                "  float normalLength = length(normal);\n"
                "  if (normalLength > 0.0)\n"
                "    {\n"
                "    normal = normalize(normal);\n"
                "    }\n"
                "  else\n"
                "    {\n"
                "    normal = vec3(0.0, 0.0, 0.0);\n"
                "    }\n"
                "   float nDotL = dot(normal, g_vdir);\n"
                "   float nDotH = dot(normal, g_h);\n"
                "   if (nDotL < 0.0)\n"
                "     {\n"
                "     nDotL = -nDotL;\n"
                "     }\n"
                "   if (nDotH < 0.0)\n"
                "     {\n"
                "     nDotH = -nDotH;\n"
                "     }\n"
                "   if (nDotL > 0.0)\n"
                "     {\n"
                "     diffuse = nDotL * in_diffuse[component] *\n"
                "               in_lightDiffuseColor[0] * color.rgb;\n"
                "     }\n"
                "    specular = pow(nDotL, in_shininess[component]) *\n"
                "                 in_specular[component] *\n"
                "                 in_lightSpecularColor[0];\n"
                "  // For the headlight, ignore the light's ambient color\n"
                "  // for now as it is causing the old mapper tests to fail\n"
                "  finalColor.xyz = in_ambient[component] * color.rgb +\n"
                "                   diffuse + specular;"
                "  finalColor.a = color.a;\n"
                "  return finalColor;\n"
                "  }");
}

std::string RGBGradientDefination() {
    return std::string("\n"
                       "uniform sampler3D in_gradient;\n"
                       "\n"
                       " uniform sampler2D in_gradientTransferFunc;\n"
                       " uniform sampler2D in_gradientTransferFunc1;\n"
                       " uniform sampler2D in_gradientTransferFunc2;        \n"
                       "float computeGradientOpacity(vec4 grad, int component)        \n"
                       "  {        \n"
                       "  if (component == 0)        \n"
                       "    {        \n"
                       "    return texture2D(in_gradientTransferFunc, vec2(grad.r, 0.0)).r;        \n"
                       "    }        \n"
                       "  if (component == 1)        \n"
                       "    {        \n"
                       "    return texture2D(in_gradientTransferFunc1, vec2(grad.g, 0.0)).r;        \n"
                       "    }        \n"
                       "  if (component == 2)        \n"
                       "    {        \n"
                       "    return texture2D(in_gradientTransferFunc2, vec2(grad.b, 0.0)).r;        \n"
                       "    }        \n"
                       "  }        \n"
                       "\n");
}

std::string GradientDefination() {
    return std::string("\n"
                       "uniform sampler3D in_gradient;\n"
                       "\n"
                       "uniform sampler2D in_gradientTransferFunc;\n"
                       "vec4 computeGradientIntensity() {\n"
                       "    vec4 gradient = texture3D(in_gradient, g_dataPos);\n"
                       "    gradient = vec4(gradient.r,gradient.r,gradient.r,gradient.r);\n"
                       "    return gradient;\n"
                       "}\n"
                       "float computeGradientOpacity(vec4 grad, int component)\n"
                       "{\n"
                       "    return texture2D(in_gradientTransferFunc, vec2(grad.w, 0.0)).r;\n"
                       "}\n"
                       "\n");
}

std::string noGradientDefination() {
    return std::string("\n"
                       "vec4 computeGradientIntensity() {\n"
                       "    return vec4(1.0);\n"
                       "}\n"
                       "float computeGradientOpacity(vec4 grad, int component)\n"
                       "{\n"
                       "    return 1.0;\n"
                       "}\n"
                       "\n");
}

std::string RGBMaximumIntensityProjection() {
    return std::string("        vec4 scalar = texture3D(in_volume, g_dataPos);\n"
                       "        scalar = scalar*in_volume_scale + in_volume_bias;\n"
                       "        for (int i = 0; i < in_noOfComponents; ++i)\n"
                       "        {\n"
                       "            if ((l_maxValue[i] < scalar[i] || l_firstValue) && !l_skip)\n"
                       "            {\n"
                       "                l_maxValue[i] = scalar[i];\n"
                       "            }\n"
                       "        }\n"
                       "\n"
                       "        if (l_firstValue && !l_skip)\n"
                       "        {\n"
                       "            l_firstValue = false;\n"
                       "        }\n"
                       "\n"
                       "        g_dataPos += g_dirStep;\n"
                       "\n"
                       "        stop = dot(sign(g_dataPos - l_tex_min), sign(l_tex_max - g_dataPos)) < 3.0;\n"
                       "        if (stop)\n"
                       "        {\n"
                       "            break;\n"
                       "        }\n"
                       "\n"
                       "        if(l_currentT >= l_terminatePointMax)\n"
                       "        {\n"
                       "            break;\n"
                       "       }\n"
                       "        l_currentT+= 1.0;\n");
}

std::string RGBMinimumIntensityProjection() {
    return std::string("        vec4 scalar = texture3D(in_volume, g_dataPos);\n"
                       "        scalar = scalar*in_volume_scale + in_volume_bias;\n"
                       "        for (int i = 0; i < in_noOfComponents; ++i)\n"
                       "        {\n"
                       "            if ((l_minValue[i] > scalar[i] || l_firstValue) && !l_skip)\n"
                       "            {\n"
                       "                l_minValue[i] = scalar[i];\n"
                       "            }\n"
                       "        }\n"
                       "\n"
                       "        if (l_firstValue &&  !l_skip)\n"
                       "        {\n"
                       "            l_firstValue = false;\n"
                       "        }\n"
                       "\n"
                       "        g_dataPos += g_dirStep;\n"
                       "\n"
                       "        stop = dot(sign(g_dataPos - l_tex_min), sign(l_tex_max - g_dataPos)) < 3.0;\n"
                       "        if (stop)\n"
                       "        {\n"
                       "            break;\n"
                       "        }\n"
                       "\n"
                       "        if(l_currentT >= l_terminatePointMax)\n"
                       "        {\n"
                       "            break;\n"
                       "       }\n"
                       "        l_currentT+= 1.0;\n");
}


std::string RGBAverageIntensityProjection() {
    return std::string("        l_numSamples[0] = l_numSamples[0] + 1u;\n"
                       "        vec4 scalar = texture3D(in_volume, g_dataPos);\n"
                       "        scalar = scalar*in_volume_scale + in_volume_bias;\n"
                       "        if (!l_skip) {\n"
                       "            for (int i = 0; i < in_noOfComponents; ++i)\n"
                       "            {\n"
                       "                l_avgValue[i] += scalar[i];\n"
                       "            }\n"
                       "        }\n"
                       "\n"
                       "        g_dataPos += g_dirStep;\n"
                       "\n"
                       "        stop = dot(sign(g_dataPos - l_tex_min), sign(l_tex_max - g_dataPos)) < 3.0;\n"
                       "        if (stop)\n"
                       "        {\n"
                       "            break;\n"
                       "        }\n"
                       "\n"
                       "        if(l_currentT >= l_terminatePointMax)\n"
                       "        {\n"
                       "            break;\n"
                       "       }\n"
                       "        l_currentT+= 1.0;\n");
}


std::string MaximumIntensityProjection() {
   return std::string( "        vec4 scalar = texture3D(in_volume, g_dataPos);\n"
               "        scalar.r = scalar.r*in_volume_scale.r + in_volume_bias.r;\n"
               "        scalar = vec4(scalar.r,scalar.r,scalar.r,scalar.r);\n"
               "        if ((l_maxValue.w < scalar.x || l_firstValue) && !l_skip)\n"
               "        {\n"
               "            l_maxValue.w = scalar.x;"
               "            \n"
               "        }\n"
               "\n"
               "        if (l_firstValue)\n"
               "        {\n"
               "            l_firstValue = false;\n"
               "        }\n"
               "\n"
               "        g_dataPos += g_dirStep;\n"
               "\n"
               ""
               "        stop = dot(sign(g_dataPos - l_tex_min), sign(l_tex_max - g_dataPos)) < 3.0;\n"
               "        if (stop)\n"
               "        {\n"
               "            break;\n"
               "        }\n"
               "\n"
               "        if(l_currentT >= l_terminatePointMax)\n"
               "        {\n"
               "            break;\n"
               "       }\n"
               "        l_currentT+= 1.0;\n");
}

std::string MinimumIntensityProjection() {
   return std::string("        vec4 scalar = texture3D(in_volume, g_dataPos);\n"
               "        scalar.r = scalar.r*in_volume_scale.r + in_volume_bias.r;\n"
               "        scalar = vec4(scalar.r,scalar.r,scalar.r,scalar.r);\n"
               "        if ((l_minValue.w > scalar.x || l_firstValue) && !l_skip)\n"
               "        {\n"
               "            l_minValue.w = scalar.x;\n"
               "        }\n"
               "\n"
               "        if (l_firstValue)\n"
               "        {\n"
               "           l_firstValue = false;\n"
               "        }\n"
               "\n"
               "        g_dataPos += g_dirStep;\n"
               "\n"
               ""
               "        stop = dot(sign(g_dataPos - l_tex_min), sign(l_tex_max - g_dataPos)) < 3.0;\n"
               "        if (stop)\n"
               "        {\n"
               "            break;\n"
               "        }\n"
               "\n"
               "        if(l_currentT >= l_terminatePointMax)\n"
               "        {\n"
               "            break;\n"
               "       }\n"
               "        l_currentT+= 1.0;\n");
}

std::string AverageIntensityProjection() {
   return std::string("       l_numSamples[0] = l_numSamples[0] + 1u;\n"
               "        vec4 scalar = texture3D(in_volume, g_dataPos);\n"
               "        scalar.r = scalar.r*in_volume_scale.r + in_volume_bias.r;\n"
               "        scalar = vec4(scalar.r,scalar.r,scalar.r,scalar.r);\n"
               "        if (!l_skip) {\n"
               "            l_avgValue.w = l_avgValue.w + scalar.x;\n"
               "        }\n"
               "\n"
               "        g_dataPos += g_dirStep;\n"
               "\n"
               "        stop = dot(sign(g_dataPos - l_tex_min), sign(l_tex_max - g_dataPos)) < 3.0;\n"
               "        if (stop)\n"
               "        {\n"
               "            break;\n"
               "        }\n"
               "\n"
               "        if(l_currentT >= l_terminatePointMax)\n"
               "        {\n"
               "            break;\n"
               "       }\n"
               "        l_currentT+= 1.0;\n"
               "        \n");
}

std::string RGBColorProjection() {
            return std::string("    vec4 scalar = texture3D(in_volume, g_dataPos);\n"
                "        scalar = scalar*in_volume_scale + in_volume_bias;\n"
                "        float distance = 0.0;\n"
                "        for(int idx = 0; idx < 3; idx++) {\n"
                "            distance += pow( scalar[idx] - mc_channelWeight[idx]/255, 2.0);\n"
                "        }\n"
                "        distance = sqrt(distance)/1.732;\n"
                "        float op = 1.0 - distance * mc_transPeriod;\n"
                "        if(op < 0.0) op = 0.0;\n if(op > 1.0) op = 1.0;\n"
                "        scalar.rgb = scalar.rgb * op;\n"
                "        if (op > mc_threshold){"
                "           if (!l_skip){ l_sampledValue += scalar * remainOpacity;}\n"
                "           remainOpacity *= (1.0 - op);\n"
                "        }\n"
                "        if (remainOpacity < 0.01)\n"
                "        {\n"
                "            break;\n"
                "        }\n"
                "        if (l_firstValue)\n"
                "        {\n"
                "            l_firstValue = false;\n"
                "        }\n"
                "\n"
                "        g_dataPos += g_dirStep;\n"
                "\n"
                "        stop = dot(sign(g_dataPos - l_tex_min), sign(l_tex_max - g_dataPos)) < 3.0;\n"
                "        if (stop)\n"
                "        {\n"
                "            break;\n"
                "        }\n"
                "\n"
                "        if(l_currentT >= l_terminatePointMax)\n"
                "        {\n"
                "            break;\n"
                "       }\n"
                "        l_currentT+= 1.0;\n");
}

std::string AutoRGBCompositeProjection() {
    return std::string("        vec4 scalar = texture3D(in_volume, g_dataPos);\n"
                       "        vec4 gradient = texture3D(in_gradient, g_dataPos);\n"
                       "        scalar = scalar*in_volume_scale + in_volume_bias;\n"
                       "        float scalarSum = scalar.r * mc_channelWeight.r + scalar.g * mc_channelWeight.g + scalar.b * mc_channelWeight.b;\n"
                       "        scalarSum /= 3.0;\n"
                       "        float gradientSum = gradient.r + gradient.g + gradient.b;\n"
                       "        gradientSum /= 3.0;\n"
                       "        gradientSum *= 2;\n"
                       "        if(gradientSum > 1.0) {\n"
                       "            gradientSum = 1.0;\n"
                       "        }\n"
                       "        float pow = (mc_weight * scalarSum + (1 - mc_weight) * gradientSum) - mc_threshold;\n"
                       "        float op = 1.0 / (1.0 + exp(mc_transPeriod * pow));\n"
                       "        if(m_inverted > 0) {op *=  (1.0 - scalarSum);}\n"
                       "        else {op *= scalarSum;}\n"
                       "        scalar.rgb = scalar.rgb * op;\n"
                       "        if(!l_skip) {l_sampledValue += scalar * remainOpacity;}\n"
                       "        remainOpacity *= (1.0 - op);\n"
                       "        if (remainOpacity < 0.01)\n"
                       "        {\n"
                       "            break;\n"
                       "        }\n"
                       "        if (l_firstValue)\n"
                       "        {\n"
                       "            l_firstValue = false;\n"
                       "        }\n"
                       "\n"
                       "        g_dataPos += g_dirStep;\n"
                       "\n"
                       "        stop = dot(sign(g_dataPos - l_tex_min), sign(l_tex_max - g_dataPos)) < 3.0;\n"
                       "        if (stop)\n"
                       "        {\n"
                       "            break;\n"
                       "        }\n"
                       "\n"
                       "        if(l_currentT >= l_terminatePointMax)\n"
                       "        {\n"
                       "            break;\n"
                       "       }\n"
                       "        l_currentT+= 1.0;\n");
}

std::string AlphaRGBCompositeProjection() {
    return std::string("        vec4 scalar = texture3D(in_volume, g_dataPos);\n"
                       "        vec4 gradient = texture3D(in_gradient, g_dataPos);\n"
                       "        scalar = scalar*in_volume_scale + in_volume_bias;\n"
                       "        vec4 gradientOpacity = vec4(0.0);\n"
                       "        vec4 scalarOpacity = vec4(0.0);\n"
                       "        if (l_firstValue)\n"
                       "        {\n"
                       "            gradient = vec4(0.0);\n"
                       "        }\n"
                       "        \n"
                       "        float totalAlpha = 0.0;\n"
                       "        vec4 tmpAlpha = vec4(0.0);\n"
                       "        for(int i = 0; i < in_noOfComponents; i++){\n"
                       "            scalarOpacity[i] = computeOpacity(scalar,i);\n"
                       "            gradientOpacity[i] = computeGradientOpacity(gradient,i);\n"
                       "        }\n"
                       "        for (int i = 0; i < in_noOfComponents; ++i)\n"
                       "        {\n"
                       "             tmpAlpha[i] = scalarOpacity[i] * gradientOpacity[i];\n"
                       "             totalAlpha += scalarOpacity[i] * gradientOpacity[i];\n"
                       "        }\n"
                       "        if(totalAlpha > 0 && !l_skip) { \n"
                       "            for (int i = 0; i < in_noOfComponents; ++i)\n"
                       "            {\n"
                       "                vec4 tmpcolor = computeColor(scalar, 1.0, i);\n;\n"
                       "                l_sampledValue[0] += tmpcolor[0] * tmpAlpha[i];\n"
                       "                l_sampledValue[1] += tmpcolor[1] * tmpAlpha[i];\n"
                       "                l_sampledValue[2] += tmpcolor[2] * tmpAlpha[i];\n"
                       "                l_sampledValue[3] += tmpAlpha[i] * tmpAlpha[i] / totalAlpha;\n"
                       "            }\n"
                       "        }\n"
                       "        remainOpacity *= 1 - l_sampledValue[3];\n "
                       "        if (remainOpacity < 0.01)\n"
                       "        {\n"
                       "            break;\n"
                       "        }\n"
                       "        if (l_firstValue)\n"
                       "        {\n"
                       "            l_firstValue = false;\n"
                       "        }\n"
                       "\n"
                       "        g_dataPos += g_dirStep;\n"
                       "\n"
                       "        stop = dot(sign(g_dataPos - l_tex_min), sign(l_tex_max - g_dataPos)) < 3.0;\n"
                       "        if (stop)\n"
                       "        {\n"
                       "            break;\n"
                       "        }\n"
                       "\n"
                       "        if(l_currentT >= l_terminatePointMax)\n"
                       "        {\n"
                       "            break;\n"
                       "        }\n"
                       "        l_currentT+= 1.0;\n");
}

std::string AlphaCompositeProjection() { //l)maxValue in this function will contains the blended pixel value
    return std::string(    
        "        vec4 scalar = texture3D(in_volume, g_dataPos);\n"
        "        scalar.r = scalar.r*in_volume_scale.r + in_volume_bias.r;\n"
        "        scalar = vec4(scalar.r,scalar.r,scalar.r,scalar.r);\n"
        "        float scalarOpacity = computeOpacity(scalar);\n"
        "        vec4 gradient = computeGradientIntensity();\n"
        "        float gradientOpacity = computeGradientOpacity(gradient, 0);\n"
        "        vec4 tmpcolor = vec4(0); tmpcolor.w = scalar.r; \n"
        "        if(scalarOpacity * gradientOpacity > 0 && !l_skip) {\n   "
        "           vec4 temcolor = computeColor(tmpcolor, 1.0);"
        "           temcolor.rgb = temcolor.rgb * scalarOpacity * gradientOpacity;\n"
        "           l_sampledValue += temcolor * remainOpacity;\n"
        "           remainOpacity *= (1- scalarOpacity * gradientOpacity);\n"
        "        }\n"
        "        if (remainOpacity < 0.01)\n"
        "        {\n"
        "            break;\n"
        "        }\n"
        "\n"
        "        if (l_firstValue)\n"
        "        {\n"
        "            l_firstValue = false;\n"
        "        }\n"
        "\n"
        "        g_dataPos += g_dirStep;\n"
        "\n"
        ""
        "        stop = dot(sign(g_dataPos - l_tex_min), sign(l_tex_max - g_dataPos)) < 3.0;\n"
        "        if (stop)\n"
        "        {\n"
        "            break;\n"
        "        }\n"
        "\n"
        "        if(l_currentT >= l_terminatePointMax)\n"
        "        {\n"
        "            break;\n"
        "       }\n"
        "        l_currentT+= 1.0;\n");
}

std::string AutoCompositeProjection() {
    return std::string("        vec4 scalar = texture3D(in_volume, g_dataPos);"
                       "\n      scalar.r = scalar.r*in_volume_scale.r + in_volume_bias.r;"
                       "\n      scalar = vec4(scalar.r,scalar.r,scalar.r,scalar.r);"
                       "\n      vec4 gradient = texture3D(in_gradient, g_dataPos);"
                       "\n      gradient = vec4(gradient.r,gradient.r,gradient.r,gradient.r);"
                       "\n      if (l_firstValue)"
                       "\n      {"
                       "\n          gradient = vec4(0.0);"
                       "\n      }"
                       "\n      float weighttmp = (mc_weight * scalar.w) + (1.0-mc_weight) * gradient.r;"
                       "\n      float thredweight = weighttmp - mc_threshold;"
                       "\n      float opacity = 1.0 / (1.0 + exp(mc_transPeriod * thredweight));"
                       "\n      vec4 tmpcolor = vec4(0); tmpcolor.w = scalar.r; "
                       "\n      vec4 temcolor = computeColor(tmpcolor, 1.0);"
                       "\n      temcolor.rgb = temcolor.rgb * opacity;"
                       "\n      if(!l_skip)"
                       "\n      {"
                       "\n          l_sampledValue += temcolor * remainOpacity;"
                       "\n      }"
                       "\n      remainOpacity *= 1- opacity;"
                       "\n"
                       "\n      if (remainOpacity < 0.01)"
                       "\n      {"
                       "\n          break;"
                       "\n      }"
                       "\n      if (l_firstValue)"
                       "\n      {\n"
                       "\n          l_firstValue = false;"
                       "\n      }"
                       "\n"
                       "\n      g_dataPos += g_dirStep;"
                       "\n"
                       "\n      stop = dot(sign(g_dataPos - l_tex_min), sign(l_tex_max - g_dataPos)) < 3.0;"
                       "\n      if (stop)"
                       "\n      {"
                       "\n          break;"
                       "\n      }"
                       "\n"
                       "\n      if(l_currentT >= l_terminatePointMax)"
                       "\n      {"
                       "\n          break;"
                       "\n      }"
                       "\n      l_currentT+= 1.0;");
}

const char* RGBraycasterfs = "//VTK::System::Dec\n"
"\n"
"varying vec3 ip_textureCoords;\n"
"varying vec3 ip_vertexPos;\n"
"\n"
"vec4 g_fragColor = vec4(0.0);\n"
"\n"
"vec3 g_dataPos;\n"
"vec3 g_dirStep;\n"
"vec4 g_srcColor;\n"
"vec4 g_eyePosObj;\n"
"bool g_exit;\n"

"uniform vec4 in_volume_scale;\n"
"uniform vec4 in_volume_bias;\n"
"\n"
"//VTK::Output::Dec\n"
"\n"
"//VTK::Base::Dec\n"
"\n"
"//VTK::Cropping::Dec\n"
"\n"
"//VTK::Shading::Dec\n"
"\n"
"uniform vec4 in_componentWeight;"
"\n"
"uniform float fuseCoef;\n"
"uniform int m_lightonly;\n"
"uniform int m_inverted;\n"
"uniform float mc_weight;\n"
"uniform float mc_threshold;\n"
"uniform float mc_transPeriod;\n"
"uniform vec3 mc_channelWeight;\n"
"\n"
"//VTK::ComputeOpacity::Dec\n"
"\n"
" //VQ::RGBRayCastingMethod::GradientDefinition "
"\n"
"//VTK::ComputeGradient::Dec\n"
"\n"
"//VTK::ComputeLighting::Dec\n"
"\n"
"//VQ::RGBRayCastingMethod::LightDefinition\n"
"\n"
"//VTK::ComputeColor::Dec\n"
"\n"
"//VTK::ComputeRayDirection::Dec\n"
"\n"
"uniform float in_clippingPlanes[49];\n"
"uniform float in_scale;\n"
"uniform float in_bias;\n"
"void main()\n"
"{\n"
"    /// Initialize g_fragColor (output) to 0\n"
"    g_fragColor = vec4(0.0);\n"
"    g_dirStep = vec3(0.0);\n"
"    g_srcColor = vec4(0.0);\n"
"    g_exit = false;\n"
"\n"
"//VTK::Base::Init"
"\n"
"//VTK::Terminate::Init"
"\n"
"//VTK::Shading::Init"
"\n"
"//VTK::Cropping::Init"
"\n"
"    // For all samples along the ray\n"
"while (true)\n"
"{\n"
"\n"
" //VTK::Base::Impl"
"\n"
" //VTK::Cropping::Impl"
"\n"
" //VQ::RGBRayCastingMethod::Implementation"
"\n"
"}\n"
"//VTK::Shading::Exit"
"\n"
"    g_fragColor.r = g_fragColor.r * in_scale + in_bias * g_fragColor.a;\n"
"    g_fragColor.g = g_fragColor.g * in_scale + in_bias * g_fragColor.a;\n"
"    g_fragColor.b = g_fragColor.b * in_scale + in_bias * g_fragColor.a;\n"
"    if(m_lightonly == 0) {\n"
"        g_fragColor.a = fuseCoef;\n"
"    } else {\n"
"        g_fragColor.a = (g_fragColor.r + g_fragColor.g + g_fragColor.b)/3;\n"
"    }\n"
"    gl_FragData[0] = g_fragColor;\n"
"\n"
"}\n";

const char* raycasterfs = "//VTK::System::Dec\n"
"\n"
"varying vec3 ip_textureCoords;\n"
"varying vec3 ip_vertexPos;\n"
"\n"
"vec4 g_fragColor = vec4(0.0);\n"
"\n"
"vec3 g_dataPos;\n"
"vec3 g_dirStep;\n"
"vec4 g_srcColor;\n"
"vec4 g_eyePosObj;\n"
"bool g_exit;\n"

"uniform vec4 in_volume_scale;\n"
"uniform vec4 in_volume_bias;\n"
"\n"
"//VTK::Output::Dec\n"
"\n"
"//VTK::Base::Dec\n"
"\n"
"//VTK::Cropping::Dec\n"
"\n"
"//VTK::Shading::Dec\n"
"\n"
"uniform float fuseCoef;\n"
"uniform int m_lightonly;\n"
"uniform int m_inverted;\n"
"uniform float mc_weight;\n"
"uniform float mc_threshold;\n"
"uniform float mc_transPeriod;\n"
"uniform vec3 mc_channelWeight;\n"
"\n"
"//VTK::ComputeOpacity::Dec\n"
"\n"
"//VQ::RayCastingMethod::GradientDefinition "
"\n"
"//VTK::ComputeGradient::Dec"
"\n"
"//VTK::ComputeLighting::Dec\n"
"\n"
"//VQ::RayCastingMethod::LightDefinition\n"
"\n"
"//VTK::ComputeColor::Dec\n"
"\n"
"//VTK::ComputeRayDirection::Dec\n"
"\n"
"//VTK::Picking::Dec\n"
"\n"
"uniform float in_clippingPlanes[49];\n"
"uniform float in_scale;\n"
"uniform float in_bias;\n"

"// //////////////////////////////////////////////////////////////////////////////\n"
"//  /// Main\n"
"//  //////////////////////////////////////////////////////////////////////////////\n"
"void main()\n"
"{\n"
"    /// Initialize g_fragColor (output) to 0\n"
"    g_fragColor = vec4(0.0);\n"
"    g_dirStep = vec3(0.0);\n"
"    g_srcColor = vec4(0.0);\n"
"    g_exit = false;\n"
"\n"
"//VTK::Base::Init"
"\n"
"//VTK::Terminate::Init"
"\n"
"//VTK::Shading::Init"
"\n"
"//VTK::Cropping::Init"
"\n"
"// For all samples along the ray\n"
"while (true)\n"
"{\n"
"\n"
" //VTK::Base::Impl"
"\n"
" //VTK::Cropping::Impl"
"\n"
" //VQ::RayCastingMethod::Implementation"
"\n"
"}\n"
"//VTK::Shading::Exit"
"\n"
"    g_fragColor.r = g_fragColor.r * in_scale + in_bias * g_fragColor.a;\n"
"    g_fragColor.g = g_fragColor.g * in_scale + in_bias * g_fragColor.a;\n"
"    g_fragColor.b = g_fragColor.b * in_scale + in_bias * g_fragColor.a;\n"
"    if(m_lightonly == 0) {\n"
"        g_fragColor.a = fuseCoef;\n"
"    } else {\n"
"        g_fragColor.a = (g_fragColor.r + g_fragColor.g + g_fragColor.b)/3;\n"
"    }\n"
"\n"
"    gl_FragData[0] = g_fragColor;\n"
"\n"
"}\n";

#endif // VQRAYCASTERFS2_H
